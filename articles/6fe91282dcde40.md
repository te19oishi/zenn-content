---
title: "Dockerについて改めて基本を学んでみた"
emoji: "🐳"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [Docker, container]
published: false
---

# 背景

今までDockerについてはなんとなーく調べて「コンテナを使って環境構築して楽々共有・デプロイできるんだー」くらいの感覚で使っていただけだったので改めて本を読んで基礎・基本をおさらいしてみました。

# 今回読んだ本

『イラストでわかるDockerとKubernetes Software Design plus』のDockerについて書かれている2章までです。
[![](/images/6fe91282dcde40/2024-05-19-18-27-32.png)](https://amzn.to/3K9D0eE)

# まずコンテナとは

コンテナ技術とは、「1つの共有されたOS上(ホストOS)で複数の独立したアプリケーションの実行環境を作成する」技術です。
そのためコンテナないで実行されるプロセスからはあたかもOS環境を占有しているかのように見えます。

簡単に図として表すと以下のようなものになります。

![](/images/6fe91282dcde40/2024-05-19-18-49-23.png)

- コンテナ
  - 他のコンテナやホストのプロセスは見えない
- プロセス
  - 複数プロセスを実行できるが、1コンテナ1プロセスとして小さく作られることが多い
- ファイル群
  - アプリケーション実行に必要なファイル群で、他のコンテナやホストとは異なるルートファイルシステムを持つ

## 基本的な特徴

コンテナの特徴には様々なものが挙げられますが、主要な特徴としては3つ存在します。
1. 軽量な実行環境
   - リソースが隔離されたプロセスとして実行
2. 高いポータビリティ
   - 軽量なイメージ、標準仕様による統一的な操作
3. エコシステム
   - OCI、CNCFと開発者コミュニティ

順に説明します。

### 軽量な実行環境

「実行環境を作成する」という点で似た技術である、「仮想化マシン」と比較するとわかりやすいかと思います。

![](/images/6fe91282dcde40/2024-05-19-20-45-08.png)

#### 仮想マシン
仮想マシンはAWS, Azure, GCPに代表されるクラウドサービスにおいても主要な実行環境の1つです。
ハードウェアとOSの間にハイパーバイザと呼ばれる管理層を作ることで仮想的に提供されるハードウェア資源とその上で動作するものをまとめて「仮想マシン」と呼ぶこともあります。

#### コンテナ技術
ホストとなるOSカーネル上で環境隔離機能を用いて独立の実行環境を作り出し、その環境でアプリケーションを実行します。
つまりコンテナ自体にOSカーネルは含まれていません。

### 高いポータビリティ
様々に語られますが今回は以下の2点について注目します。
- コンテナイメージの軽量さとその挙動の再現性の強さ
- 業界標準仕様による統一的な操作方法

コンテナの実行には「コンテナイメージ」が必要になり、そのサイズは多くの場合数十MB~数百MB程度です。仮想マシンはGB級の容量になることも珍しくないため、非常に軽量であることがわかると思います。
またアプリケーションが依存するコンポーネントを全て詰め込むことでコンテナの作成時と異なる環境で実行する際にも挙動の再現性を高めることができます。

![](/images/6fe91282dcde40/2024-05-19-21-10-01.png)

さらにコンテナにまつわるツールとして、Docker, Kubernetes, CI/CD, FaaS, サービスメッシュ, エッジコンピューティング等幅広い分野で様々なものが開発されています。
これにより一度作成したコンテナを標準仕様に沿ってそれらのツール間で共通に取り扱える点で、高いポータビリティが実現されていると言えます。

### 巨大なエコシステム
コンテナ技術を取り巻くツールはOSSとして開発されているだけでも相当な数があります。
重大な役割を果たしているものの一つは、Open Container Initiative(OCI)と呼ばれる、コンテナ技術に関する標準仕様の策定などを行なっているプロジェクトです。この仕様に基づいて多様なコンテナ関連ツールが相互に連携可能な形で開発されています。
もう一つはCloud Native Computing Foundation(CNCF)で、Kubernetesを含む様々なOSSがホストされています。
これらエコシステムに関しては第4章にて詳細に書かれています。

# Dockerの概要
## Build, Ship, Run
DockerにはBuild, Ship, Runというワークフローが存在するので、まずはその全体的な流れについて説明します。

![](/images/6fe91282dcde40/2024-05-19-22-00-08.png)

### Build
コンテナイメージには、実行したいアプリケーションのバイナリやその依存関係にあるファイル群、実行環境を作成するのに必要な情報等が含まれ、そのコンテナイメージを作成する機能をBuildと言います。

### Ship
ビルドしたイメージを「レジストリ」と呼ばれるイメージ配布用のサーバを用いることで他のホストに配布・共有できます。Dockerはこのレジストリにイメージをアップロード(Push)したりダウンロード(Pull)する機能を持ち、それをShipと言います。

### Run
そうして得られたイメージを実行することをRunと言います。

## Build:コンテナイメージの作成
Dockerに**コンテキスト**と**Dockerfile**を与えることで、Dockerfileに記された手順に沿って、与えられたコンテキストに含まれるファイル群が適宜用いられながら1つのイメージにまとめられていきます。

![](/images/6fe91282dcde40/2024-05-20-07-14-42.png)

## Run:コンテナの実行
コンテナの実行は`docker run`コマンドで行います。

![](/images/6fe91282dcde40/2024-05-20-08-59-21.png)

そして`--name`オプションでコンテナ名をつけ、`docker exec`コマンドで新たなシェルを実行できます。

例えば、
```:terminal
docker run --name container-name myimage:v1
```
これで`myimage`というイメージからコンテナを`container-name`という名前で実行します。
そして
```:terminal
docker exec -it container-name /bin/bash
```

するとコンテナ内でbashを開き、lsやcdコマンド等を使えるようになります。

## Ship:レジストリを用いたコンテナの配布

「レジストリ」と呼ばれるイメージ配布用のサーバーを通じて他のホストと共有することができます。

![](/images/6fe91282dcde40/2024-05-30-21-01-56.png)

レジストリサービスはさまざまなものが存在しますが、その中で代表的なものとしてDocker Hubがあります。
`myimage:v1`というイメージを作成したとして、それをDocker Hubに`Push`し、それを別のホストから`Pull`するkとで同一のイメージを利用することができるという仕組みです。

# コンテナのレイヤ構造

コンテナイメージとそこから実行されるコンテナの構造を知っておくとより理解が深まるため、イメージがコンテナのルートファイルシステムのデータをどのように保持しているかに注目します。

## コンテナイメージのレイヤ構造
コンテナを操作する上で重要な点として、コンテナは**変更差分の集まり**であるというものがあります。

![](/images/6fe91282dcde40/2024-05-30-21-36-59.png)

ベースのレイヤの上にアプリケーションAをインストールし、さらにファイルBを追加するという差分を集めたものが「コンテナ」と呼ばれ、それぞれの変更差分は「レイヤ」と呼ばれます。

## コンテナのビルドとレイヤ構造
コンテナをビルドする際の作成手順書としてDockerfileを用いますが、コンテナのレイヤ構造にも深く関わっています。

Dockerfileには、`命令 引数`というフォーマットで行単位で記述します。これをファイルの先頭から実行することでイメージを作成していきます。

![](/images/6fe91282dcde40/2024-05-30-22-06-30.png)

さらにDockerはDockerfileの変更差分をキャッシュしながらビルドを進めることで、以降同様のビルドを行う際はそのキャッシュを用いることでビルド時間の短縮に貢献しています。

イメージをビルドする際は、キャッシュの使われ方やレイヤ構造を意識することによりより効率的なビルドを行うことができます。
