---
title: "A Tour of Go をやってみた"
emoji: "💻"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [Go, Tutorial,]
published: false
---

## 1. 概要

Go言語が利用されているプロダクトが増加傾向のようなので公式チュートリアルでもある「A Tour of Go」である程度学んでみたいと思う。

:::details Welcome!

## 2. Welcome!

今回は1回目の「Welcome!」を行う。

https://go-tour-jp.appspot.com/welcome/1

### 2.1. Wello World

とりあえず実行してみなさいと言われたので実行しました。

```go:hello.go
package main

import "fmt"

func main() {
	fmt.Println("Hello, 世界")
}
```
```:Run
Hello, 世界
```

日本語訳版なので「Hello, World」ではなく「Hello, 世界」となっていますが、それは気にする問題ではありません。

### 2.2. Go local

Go Tourは英語以外にもドイツ語や中国語、韓国語等、さまざまな言語で利用できるようです。

### 2.3. Go offline

今回私はブラウザ上でコードを実行しますが、ローカルで実行する方法が記載されていました。

[Goのダウンロードとインストール](https://go.dev/dl/)をして、`go tool tour`と実行することでローカルでの実行が可能になるようです。

### 2.4. The Go Playground

ブラウザ上で実行する時は常に`2009-11-10 23:00:00 UTC`らしいです。これで同一の実行結果を得ることが容易になるんですね。実行結果にも現れています。
常に最新の安定バージョンを利用できるそうなので何も考えずブラウザ上で実行すれば良さそうです。

```go:sandbox.go
package main

import (
	"fmt"
	"time"
)

func main() {
	fmt.Println("Welcome to the playground!")

	fmt.Println("The time is", time.Now())
}
```

```:Run
Welcome to the playground!
The time is 2009-11-10 23:00:00 +0000 UTC m=+0.000000001
```

### 2.5. まとめ
- Go PlaygroundというWebサービスのサンドボックス内でコンパイル、リンク、実行している
- 常に`2009-11-10 23:00:00 UTC`である

:::

:::details Packages, variables, and functions.

## 3. Packages, variables, and functions.

### 3.1. Packages

Goは`package`(パッケージ)で構成されており、このプログラムは`main`パッケージです。
今回は`fmt`と`math/rand`の二つのパッケージを`import`(インポート)しています。

```go:packages.go
package main

import (
	"fmt"
	"math/rand"
)

func main() {
	fmt.Println("My favorite number is", rand.Intn(10))
}
```

```:Run
My favorite number is 7
```

Go Playgroundでは時刻が一定なのでランダムに生成する`rand`を用いても出力結果は一定(7)となります。



### 3.2. Imports

括弧でパッケージのインポートをグループ化しており、公式にもこの記法(factored import statement)が推奨されていますが、以下のように複数のimport文を書くこともできます。

`import "fmt"`
`import "math"`

```go:imports.go
package main

import (
	"fmt"
	"math"
)

func main() {
	fmt.Printf("Now you have %g problems.\n", math.Sqrt(7))
}
```
```:Run
Now you have 2.6457513110645907 problems.
```

### 3.3. Exported names

一文字目が大文字で始まる名前は外部のパッケージから参照された名前(exported name)です。
反対に小文字で始まる名前は外部のパッケージから参照することができません。

そこで以下のプログラムを実行してみます。

```go:exported-names.go
package main

import (
	"fmt"
	"math"
)

func main() {
	fmt.Println(math.pi)
}
```

```:Run
./prog.go:9:19: undefined: math.pi
```

エラーが出てしまいました。「math.piは定義されてないよ」と言われています。小文字から始まる名前は外部パッケージから参照できませんので、`math.Pi`に変更して実行してみます。

```diff go:exported-names.go
package main

import (
	"fmt"
	"math"
)

func main() {
-	fmt.Println(math.pi)
+	fmt.Println(math.Pi)
}
```
```:Run
3.141592653589793
```

無事に円周率が表示されました。

### 3.4. Functions

今回のadd関数はint型の2つの引数を取りますが、**変数名の後ろ**に型名を記述します。

```go:functions.go
package main

import "fmt"

func add(x int, y int) int {
	return x + y
}

func main() {
	fmt.Println(add(42, 13))
}
```
```:Run
55
```

42+13の結果が出力されています。

### 3.5. Functions continued

複数の引数の型が同一の時、最後だけ残して省略することができます。例えば以下のようにします。

```diff go:functions-continued.go
package main

import "fmt"

-func add(x int, y int) int {
+func add(x, y int) int {
	return x + y
}

func main() {
	fmt.Println(add(42, 13))
}
```
```:Run
55
```

### 3.6. Multiple results

複数の戻り値を返すこともできます。
以下のswap関数を見てみます。

```go:multiple-result.go
package main

import "fmt"

func swap(x, y string) (string, string) {
	return y, x
}

func main() {
	a, b := swap("hello", "world")
	fmt.Println(a, b)
}
```
```:Run
world hello
```

このように、a,bそれぞれに代入できています。

### 3.7. Named return values

戻り値となる変数に名前をつけることができます。こうすることで、returnのみで値を返すことができます。('naked return')
長い関数で利用すると読みやすさに悪影響を与えるため、短い関数でのみ利用するべきです。

```go:named-result.go
package main

import "fmt"

func split(sum int) (x, y int) {
	x = sum * 4 / 9
	y = sum - x
	return
}

func main() {
	fmt.Println(split(17))
}
```
```:Run
7 10
```

### 3.8. Variables

var文は変数を宣言することができます。これも関数の引数と同様に変数名の最後に型名を書くことで省略することができます。

```go:variables.go
package main

import "fmt"

var c, python, java bool

func main() {
	var i int
	fmt.Println(i, c, python, java)
}
```
```:Run
0 false false false
```

ご覧の通り、関数内でもvar文は利用可能です。

### 3.9. Variables with initializers

varで変数を宣言する際に初期化子を与えることができます。その際、型を省略することができるようになります。

```go:variables-with-initializers.go
package main

import "fmt"

var i, j int = 1, 2

func main() {
	var c, python, java = true, false, "no!"
	fmt.Println(i, j, c, python, java)
}
```
```:Run
1 2 true false no!
```
main関数内では型宣言をしていませんが、初期化子を与えることで動作させることができています。

### 3.10. Short variable declarations

**関数の中でのみ**varの代わりに`:=`の暗黙的な型宣言が可能です。

```go short-variable-declarations
package main

import "fmt"

func main() {
	var i, j int = 1, 2
	k := 3
	c, python, java := true, false, "no!"

	fmt.Println(i, j, k, c, python, java)
}
```
```:Run
1 2 3 true false no!
```

### 3.11. Basic types

基本型は以下の通りです。
```
bool

string

int  int8  int16  int32  int64
uint uint8 uint16 uint32 uint64 uintptr

byte // uint8 の別名

rune // int32 の別名
     // Unicode のコードポイントを表す

float32 float64

complex64 complex128
```

```go:basec-types.go
package main

import (
	"fmt"
	"math/cmplx"
)

var (
	ToBe   bool       = false
	MaxInt uint64     = 1<<64 - 1
	z      complex128 = cmplx.Sqrt(-5 + 12i)
)

func main() {
	fmt.Printf("Type: %T Value: %v\n", ToBe, ToBe)
	fmt.Printf("Type: %T Value: %v\n", MaxInt, MaxInt)
	fmt.Printf("Type: %T Value: %v\n", z, z)
}
```
```:Run
Type: bool Value: false
Type: uint64 Value: 18446744073709551615
Type: complex128 Value: (2+3i)
```

### 3.12. Zero values

変数に初期値を与えない場合はゼロ値が代入されます。

| 型       | 値    |
| -------- | ----- |
| 整数型   | 0     |
| bool型   | false |
| string型 | ""    |

```go:zero.go
package main

import "fmt"

func main() {
	var i int
	var f float64
	var b bool
	var s string
	fmt.Printf("%v %v %v %q\n", i, f, b, s)
}
```
```:Run
0 0 false ""
```

### 3.13. Type conversions

変数`v`、型`T`があった時、型変換は`T(v)`で行います。

```go:type-conversions.go
package main

import (
	"fmt"
	"math"
)

func main() {
	var x, y int = 3, 4
	var f float64 = math.Sqrt(float64(x*x + y*y))
	var z uint = uint(f)
	fmt.Println(x, y, z)
}
```
```:Run
3 4 5
```

以下のように省略して記述することも可能です。

```diff go:type-conversions.go
package main

import (
	"fmt"
	"math"
)

func main() {
-	var x, y int = 3, 4
-	var f float64 = math.Sqrt(float64(x*x + y*y))
-	var z uint = uint(f)
+	x, y  := 3, 4
+	f := math.Sqrt(float64(x*x + y*y))
+	z := uint(f)
	fmt.Println(x, y, z)
}
```
```:Run
3 4 5
```

### 3.14. Type inference

`:=`や`var =`等で明示的な型を指定しない場合、右側の変数から型推論されます。
型を指定しない数値である場合、右側の定数の精度に基づいて`int`,`float64`,`complex128`になります。

```go:type-inference.go
package main

import "fmt"

func main() {
	v := 42 // change me!
	fmt.Printf("v is of type %T\n", v)
}
```
```:Run
v is of type int
```

`change me!`と言われているため3.14に変更してみます。


```diff go:type-inference.go
package main

import "fmt"

func main() {
-	v := 42 // change me!
+	v := 3.14 // change me!
	fmt.Printf("v is of type %T\n", v)
}
```
```:Run
v is of type float64
```

`int`から`float64`に変わりました。

### 3.15. Constants

定数は`const`を用いて宣言します。
ただし、`:=`を利用することはできません。

```go:constants.go
package main

import "fmt"

const Pi = 3.14

func main() {
	const World = "世界"
	fmt.Println("Hello", World)
	fmt.Println("Happy", Pi, "Day")

	const Truth = true
	fmt.Println("Go rules?", Truth)
}
```
```:Run
Hello 世界
Happy 3.14 Day
Go rules? true
```

### 3.16. Numeric Constants

型のない定数は状況により必要な型を取ることになります。
以下のプログラムでは、`Big`,`Small`に型が宣言されていないため計算結果により型が変わっています。

```go:numeric-constants.go
package main

import "fmt"

const (
	// Create a huge number by shifting a 1 bit left 100 places.
	// In other words, the binary number that is 1 followed by 100 zeroes.
	Big = 1 << 100
	// Shift it right again 99 places, so we end up with 1<<1, or 2.
	Small = Big >> 99
)

func needInt(x int) int { return x*10 + 1 }
func needFloat(x float64) float64 {
	return x * 0.1
}

func main() {
	fmt.Println(needInt(Small))
	fmt.Println(needFloat(Small))
	fmt.Println(needFloat(Big))
}
```

 ```:Run
21
0.2
1.2676506002282295e+29
 ```

ちなみに`needInt(Big)`とすると値が大きくなりすぎてオーバーフローしエラーが出力されました。

### 3.17. まとめ

- Goのプログラムは`package`(パッケージ)で構成される
- エントリーポイントはmain関数
- 大文字から始まる名前**だけ**外部パッケージから参照することができる
- 型名は**変数の後ろ**に書く
- 同じ型の引数が複数ある場合型の宣言は最後だけ残して省略できる
- 戻り値となる変数に名前をつけることでreturn文に何も書かなくても良くなる
- var文で変数を宣言し、引数同様型宣言の省略も可能
- 初期化子を与えることで型宣言を省略可能
- **関数の中でのみ**varの代わりに`:=`の暗黙的な型宣言が可能です
- 変数に初期値を与えない場合、ゼロ値が代入される
- 変数`v`、型`T`があった時、型変換は`T(v)`で行う
- `:=`や`var =`等で明示的な型を指定しない場合、右側の変数から型推論される
- 定数は`const`を用いて宣言できるが、`:=`を利用することはできない。
- 型のない定数は状況により必要な型を取ることになる。

:::

:::details Flow control statements: for, if, else, switch and defer

## Flow control statements: for, if, else, switch and defer

### For

for文は、初期化・条件・後処理の3つの処理がセミコロン`;`で分けられています。
CやJava等の言語との違いとして、それらを囲う丸括弧`()`が必要ないということです。

```go:for.go
package main

import "fmt"

func main() {
	sum := 0
	for i := 0; i < 10; i++ {
		sum += i
	}
	fmt.Println(sum)
}
```
```:Run
45
```

### For continued

初期化と後処理は任意です。
不要な場合は`;`のみ記述します。

```diff go:for-continued.go
package main

import "fmt"

func main() {
	sum := 1
-	for i := 0; i < 10; i++ {
+	for ; sum < 1000; {
		sum += sum
	}
	fmt.Println(sum)
}
```
```:Run
1024
```

### For is Go's "while"

なんなら、`;`を省略することだってできてしまいます。つまりC言語等のwhile文はGo言語におけるfor文であるのです。

```diff go:for-is-gos-while.go
package main

import "fmt"

func main() {
	sum := 1
-	for ; sum < 1000; {
+	for sum < 1000 {
		sum += sum
	}
	fmt.Println(sum)
}
```
```:Run
1024
```

### Forever

条件式を省略すると無限ループとなります。

```go:forever.go
package main

func main() {
	for {
	}
}
```
```:Run
```

### If

if文にはfor文同様に丸括弧`()`が必要ありません。

```go:if.go
package main

import (
	"fmt"
	"math"
)

func sqrt(x float64) string {
	if x < 0 {
		return sqrt(-x) + "i"
	}
	return fmt.Sprint(math.Sqrt(x))
}

func main() {
	fmt.Println(sqrt(2), sqrt(-4))
}
```
```:Run
1.4142135623730951 2i
```

### If with a short statement

for文のように条件式の前に簡単な文を書くことができます。

```go:if-with-a-short-statement
package main

import (
	"fmt"
	"math"
)

func pow(x, n, lim float64) float64 {
	if v := math.Pow(x, n); v < lim {
		return v
	}
	return lim
}

func main() {
	fmt.Println(
		pow(3, 2, 10),
		pow(3, 3, 20),
	)
}
```
```:Run
9 20
```

### If and else

if文で宣言された変数はelse文でも用いることができます。

```go:if-and-else.go
package main

import (
	"fmt"
	"math"
)

func pow(x, n, lim float64) float64 {
	if v := math.Pow(x, n); v < lim {
		return v
	} else {
		fmt.Printf("%g >= %g\n", v, lim)
	}
	// can't use v here, though
	return lim
}

func main() {
	fmt.Println(
		pow(3, 2, 10),
		pow(3, 3, 20),
	)
}
```
```:Run
27 >= 20
9 20
```

なお、main関数の`Println`は先にpow関数が実行されてから実行されるため、pow関数の`Printf`が先に実行され、その後`9 20`が出力されています。

### Exercise: Loops and Functions

関数とループを利用して平方根を計算してみます。数値`x`が与えられた時に幾つかの`z`を推測し、`z^2`がどれだけ`x`に近づいたかに応じて`z`を調節できます。

```go:exercise-loops-and-functions.go
package main

import (
	"fmt"
)

func Sqrt(x float64) float64 {
}

func main() {
	fmt.Println(Sqrt(2))
}
```

#### 解答例

`math`パッケージをインポートして出力を比較してみました。

```diff go:exercise-loops-and-functions.go
package main

import (
	"fmt"
+	"math"
)

func Sqrt(x float64) float64 {
+	z := 1.0
+	for i := 0; i < 10; i++ {
+		z -= (z*z - x) / (2*z)
+	}
+	return z
}

func main() {
	fmt.Println(Sqrt(2))
+	fmt.Println(math.Sqrt(2))
}
```

### Switch

switch文は`if-else`文を短く書くことができます。

他言語と比較してGo言語は、選択された`case`のみ実行しその他の`case`は実行されません。また、最後に必要な`break`も自動で提供されるため必要ありません。
さらに、`case`は**定数でも整数でもなくて良い**のです。

```go:switch.go
package main

import (
	"fmt"
	"runtime"
)

func main() {
	fmt.Print("Go runs on ")
	switch os := runtime.GOOS; os {
	case "darwin":
		fmt.Println("OS X.")
	case "linux":
		fmt.Println("Linux.")
	default:
		// freebsd, openbsd,
		// plan9, windows...
		fmt.Printf("%s.\n", os)
	}
}
```
```:Run
Go runs on Linux.
```

### Switch evaluation order

`case`文は上から下に評価されるため、条件が一致するとそこで`switch`文は終了(自動的にbreak)します。

```go:switch-evaluation-order.go
package main

import (
	"fmt"
	"time"
)

func main() {
	fmt.Println("When's Saturday?")
	today := time.Now().Weekday()
	switch time.Saturday {
	case today + 0:
		fmt.Println("Today.")
	case today + 1:
		fmt.Println("Tomorrow.")
	case today + 2:
		fmt.Println("In two days.")
	default:
		fmt.Println("Too far away.")
	}
}
```
```:Run
When's Saturday?
Too far away.
```

この実行結果を見るに、火曜日から金曜日の間であるようです。果たして`2009-11-10 23:00:00 UTC`は何曜日なのでしょうか。

### Switch with no condition

条件のない`switch`文は、`switch true`と書くことと同様です。これを利用して、長くなりがちな`if-then-else`をシンプルに表現することが可能となります。

```go:switch-with-no-condition.go
package main

import (
	"fmt"
	"time"
)

func main() {
	t := time.Now()
	switch {
	case t.Hour() < 12:
		fmt.Println("Good morning!")
	case t.Hour() < 17:
		fmt.Println("Good afternoon.")
	default:
		fmt.Println("Good evening.")
	}
}
```
```:Run
Good evening.
```

`2009-11-10 23:00:00 UTC`は23時なので`Good evening.`が出力されています。

### Defer

`defer`文は元の関数の実行を`return`するまで遅延させます。関数の引数はすぐに評価されますが、実行そのものは`return`されるまで実行されません。

```go:defer.go
package main

import "fmt"

func main() {
	defer fmt.Println("world")

	fmt.Println("hello")
}
```
```:Run
hello
world
```

### Stacking defers

`defer`を複数回利用した場合、それらはスタックされます。元の関数が`return`されると、 `LIFO`(last-in-first-out)の順で実行されます。

```go:defer-multi.go
package main

import "fmt"

func main() {
	fmt.Println("counting")

	for i := 0; i < 10; i++ {
		defer fmt.Println(i)
	}

	fmt.Println("done")
}
```
```:Run
counting
done
9
8
7
6
5
4
3
2
1
0
```

### まとめ
- `for`文には`()`が必要ない
- 初期化と後処理を省略し、他言語のwhile文同様に扱うことが可能
- 条件式を省略すると無限ループする
- `if`文にも`()`は必要ない
- 条件式の前に簡単な文を記述可能
- そこで得た変数はelse文でも利用可能
- `switch`文には`break`が必要ない
- `case`文は**定数でも整数でもなくて良い**
- `case`文は上から順に評価され、一致するとそこで終了する
- 条件のない`switch`文は`if-then-else`をシンプルに表現可能
- `defer`文は元の関数の実行を`return`するまで遅延させる
- 複数回利用した場合、それらはスタックされ、`LIFO`で実行される

:::
:::details 4
:::
:::details 5
:::
:::details 6
:::