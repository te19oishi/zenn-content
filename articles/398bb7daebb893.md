---
title: "A Tour of Go をやってみた"
emoji: "💻"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [Go, Tutorial,]
published: false
---

## 1. 概要

Go言語が利用されているプロダクトが増加傾向のようなので公式チュートリアルでもある「A Tour of Go」である程度学んでみたいと思う。

:::details Welcome!

## 2. Welcome!

今回は1回目の「Welcome!」を行う。

https://go-tour-jp.appspot.com/welcome/1

### 2.1. Wello World

とりあえず実行してみなさいと言われたので実行しました。

```go:hello.go
package main

import "fmt"

func main() {
	fmt.Println("Hello, 世界")
}
```
```:Run
Hello, 世界
```

日本語訳版なので「Hello, World」ではなく「Hello, 世界」となっていますが、それは気にする問題ではありません。

### 2.2. Go local

Go Tourは英語以外にもドイツ語や中国語、韓国語等、さまざまな言語で利用できるようです。

### 2.3. Go offline

今回私はブラウザ上でコードを実行しますが、ローカルで実行する方法が記載されていました。

[Goのダウンロードとインストール](https://go.dev/dl/)をして、`go tool tour`と実行することでローカルでの実行が可能になるようです。

### 2.4. The Go Playground

ブラウザ上で実行する時は常に`2009-11-10 23:00:00 UTC`らしいです。これで同一の実行結果を得ることが容易になるんですね。実行結果にも現れています。
常に最新の安定バージョンを利用できるそうなので何も考えずブラウザ上で実行すれば良さそうです。

```go:sandbox.go
package main

import (
	"fmt"
	"time"
)

func main() {
	fmt.Println("Welcome to the playground!")

	fmt.Println("The time is", time.Now())
}
```

```:Run
Welcome to the playground!
The time is 2009-11-10 23:00:00 +0000 UTC m=+0.000000001
```

### 2.5. まとめ
- Go PlaygroundというWebサービスのサンドボックス内でコンパイル、リンク、実行している
- 常に`2009-11-10 23:00:00 UTC`である

:::

:::details Packages, variables, and functions.

## 3. Packages, variables, and functions.

### 3.1. Packages

Goは`package`(パッケージ)で構成されており、このプログラムは`main`パッケージです。
今回は`fmt`と`math/rand`の二つのパッケージを`import`(インポート)しています。

```go:packages.go
package main

import (
	"fmt"
	"math/rand"
)

func main() {
	fmt.Println("My favorite number is", rand.Intn(10))
}
```

```:Run
My favorite number is 7
```

Go Playgroundでは時刻が一定なのでランダムに生成する`rand`を用いても出力結果は一定(7)となります。



### 3.2. Imports

括弧でパッケージのインポートをグループ化しており、公式にもこの記法(factored import statement)が推奨されていますが、以下のように複数のimport文を書くこともできます。

`import "fmt"`
`import "math"`

```go:imports.go
package main

import (
	"fmt"
	"math"
)

func main() {
	fmt.Printf("Now you have %g problems.\n", math.Sqrt(7))
}
```
```:Run
Now you have 2.6457513110645907 problems.
```

### 3.3. Exported names

一文字目が大文字で始まる名前は外部のパッケージから参照された名前(exported name)です。
反対に小文字で始まる名前は外部のパッケージから参照することができません。

そこで以下のプログラムを実行してみます。

```go:exported-names.go
package main

import (
	"fmt"
	"math"
)

func main() {
	fmt.Println(math.pi)
}
```

```:Run
./prog.go:9:19: undefined: math.pi
```

エラーが出てしまいました。「math.piは定義されてないよ」と言われています。小文字から始まる名前は外部パッケージから参照できませんので、`math.Pi`に変更して実行してみます。

```diff go:exported-names.go
package main

import (
	"fmt"
	"math"
)

func main() {
-	fmt.Println(math.pi)
+	fmt.Println(math.Pi)
}
```
```:Run
3.141592653589793
```

無事に円周率が表示されました。

### 3.4. Functions

今回のadd関数はint型の2つの引数を取りますが、**変数名の後ろ**に型名を記述します。

```go:functions.go
package main

import "fmt"

func add(x int, y int) int {
	return x + y
}

func main() {
	fmt.Println(add(42, 13))
}
```
```:Run
55
```

42+13の結果が出力されています。

### 3.5. Functions continued

複数の引数の型が同一の時、最後だけ残して省略することができます。例えば以下のようにします。

```diff go:functions-continued.go
package main

import "fmt"

-func add(x int, y int) int {
+func add(x, y int) int {
	return x + y
}

func main() {
	fmt.Println(add(42, 13))
}
```
```:Run
55
```

### 3.6. Multiple results

複数の戻り値を返すこともできます。
以下のswap関数を見てみます。

```go:multiple-result.go
package main

import "fmt"

func swap(x, y string) (string, string) {
	return y, x
}

func main() {
	a, b := swap("hello", "world")
	fmt.Println(a, b)
}
```
```:Run
world hello
```

このように、a,bそれぞれに代入できています。

### 3.7. Named return values

戻り値となる変数に名前をつけることができます。こうすることで、returnのみで値を返すことができます。('naked return')
長い関数で利用すると読みやすさに悪影響を与えるため、短い関数でのみ利用するべきです。

```go:named-result.go
package main

import "fmt"

func split(sum int) (x, y int) {
	x = sum * 4 / 9
	y = sum - x
	return
}

func main() {
	fmt.Println(split(17))
}
```
```:Run
7 10
```

### 3.8. Variables

var文は変数を宣言することができます。これも関数の引数と同様に変数名の最後に型名を書くことで省略することができます。

```go:variables.go
package main

import "fmt"

var c, python, java bool

func main() {
	var i int
	fmt.Println(i, c, python, java)
}
```
```:Run
0 false false false
```

ご覧の通り、関数内でもvar文は利用可能です。

### 3.9. Variables with initializers

varで変数を宣言する際に初期化子を与えることができます。その際、型を省略することができるようになります。

```go:variables-with-initializers.go
package main

import "fmt"

var i, j int = 1, 2

func main() {
	var c, python, java = true, false, "no!"
	fmt.Println(i, j, c, python, java)
}
```
```:Run
1 2 true false no!
```
main関数内では型宣言をしていませんが、初期化子を与えることで動作させることができています。

### 3.10. Short variable declarations

**関数の中でのみ**varの代わりに`:=`の暗黙的な型宣言が可能です。

```go short-variable-declarations
package main

import "fmt"

func main() {
	var i, j int = 1, 2
	k := 3
	c, python, java := true, false, "no!"

	fmt.Println(i, j, k, c, python, java)
}
```
```:Run
1 2 3 true false no!
```

### 3.11. Basic types

基本型は以下の通りです。
```
bool

string

int  int8  int16  int32  int64
uint uint8 uint16 uint32 uint64 uintptr

byte // uint8 の別名

rune // int32 の別名
     // Unicode のコードポイントを表す

float32 float64

complex64 complex128
```

```go:basec-types.go
package main

import (
	"fmt"
	"math/cmplx"
)

var (
	ToBe   bool       = false
	MaxInt uint64     = 1<<64 - 1
	z      complex128 = cmplx.Sqrt(-5 + 12i)
)

func main() {
	fmt.Printf("Type: %T Value: %v\n", ToBe, ToBe)
	fmt.Printf("Type: %T Value: %v\n", MaxInt, MaxInt)
	fmt.Printf("Type: %T Value: %v\n", z, z)
}
```
```:Run
Type: bool Value: false
Type: uint64 Value: 18446744073709551615
Type: complex128 Value: (2+3i)
```

### 3.12. Zero values

変数に初期値を与えない場合はゼロ値が代入されます。

| 型       | 値    |
| -------- | ----- |
| 整数型   | 0     |
| bool型   | false |
| string型 | ""    |

```go:zero.go
package main

import "fmt"

func main() {
	var i int
	var f float64
	var b bool
	var s string
	fmt.Printf("%v %v %v %q\n", i, f, b, s)
}
```
```:Run
0 0 false ""
```

### 3.13. Type conversions

変数`v`、型`T`があった時、型変換は`T(v)`で行います。

```go:type-conversions.go
package main

import (
	"fmt"
	"math"
)

func main() {
	var x, y int = 3, 4
	var f float64 = math.Sqrt(float64(x*x + y*y))
	var z uint = uint(f)
	fmt.Println(x, y, z)
}
```
```:Run
3 4 5
```

以下のように省略して記述することも可能です。

```diff go:type-conversions.go
package main

import (
	"fmt"
	"math"
)

func main() {
-	var x, y int = 3, 4
-	var f float64 = math.Sqrt(float64(x*x + y*y))
-	var z uint = uint(f)
+	x, y  := 3, 4
+	f := math.Sqrt(float64(x*x + y*y))
+	z := uint(f)
	fmt.Println(x, y, z)
}
```
```:Run
3 4 5
```

### 3.14. Type inference

`:=`や`var =`等で明示的な型を指定しない場合、右側の変数から型推論されます。
型を指定しない数値である場合、右側の定数の精度に基づいて`int`,`float64`,`complex128`になります。

```go:type-inference.go
package main

import "fmt"

func main() {
	v := 42 // change me!
	fmt.Printf("v is of type %T\n", v)
}
```
```:Run
v is of type int
```

`change me!`と言われているため3.14に変更してみます。


```diff go:type-inference.go
package main

import "fmt"

func main() {
-	v := 42 // change me!
+	v := 3.14 // change me!
	fmt.Printf("v is of type %T\n", v)
}
```
```:Run
v is of type float64
```

`int`から`float64`に変わりました。

### 3.15. Constants

定数は`const`を用いて宣言します。
ただし、`:=`を利用することはできません。

```go:constants.go
package main

import "fmt"

const Pi = 3.14

func main() {
	const World = "世界"
	fmt.Println("Hello", World)
	fmt.Println("Happy", Pi, "Day")

	const Truth = true
	fmt.Println("Go rules?", Truth)
}
```
```:Run
Hello 世界
Happy 3.14 Day
Go rules? true
```

### 3.16. Numeric Constants

型のない定数は状況により必要な型を取ることになります。
以下のプログラムでは、`Big`,`Small`に型が宣言されていないため計算結果により型が変わっています。

```go:numeric-constants.go
package main

import "fmt"

const (
	// Create a huge number by shifting a 1 bit left 100 places.
	// In other words, the binary number that is 1 followed by 100 zeroes.
	Big = 1 << 100
	// Shift it right again 99 places, so we end up with 1<<1, or 2.
	Small = Big >> 99
)

func needInt(x int) int { return x*10 + 1 }
func needFloat(x float64) float64 {
	return x * 0.1
}

func main() {
	fmt.Println(needInt(Small))
	fmt.Println(needFloat(Small))
	fmt.Println(needFloat(Big))
}
```

 ```:Run
21
0.2
1.2676506002282295e+29
 ```

ちなみに`needInt(Big)`とすると値が大きくなりすぎてオーバーフローしエラーが出力されました。

### 3.17. まとめ

- Goのプログラムは`package`(パッケージ)で構成される
- エントリーポイントはmain関数
- 大文字から始まる名前**だけ**外部パッケージから参照することができる
- 型名は**変数の後ろ**に書く
- 同じ型の引数が複数ある場合型の宣言は最後だけ残して省略できる
- 戻り値となる変数に名前をつけることでreturn文に何も書かなくても良くなる
- var文で変数を宣言し、引数同様型宣言の省略も可能
- 初期化子を与えることで型宣言を省略可能
- **関数の中でのみ**varの代わりに`:=`の暗黙的な型宣言が可能です
- 変数に初期値を与えない場合、ゼロ値が代入される
- 変数`v`、型`T`があった時、型変換は`T(v)`で行う
- `:=`や`var =`等で明示的な型を指定しない場合、右側の変数から型推論される
- 定数は`const`を用いて宣言できるが、`:=`を利用することはできない。
- 型のない定数は状況により必要な型を取ることになる。

:::

:::details Flow control statements: for, if, else, switch and defer

## 4. Flow control statements: for, if, else, switch and defer

### 4.1. For

for文は、初期化・条件・後処理の3つの処理がセミコロン`;`で分けられています。
CやJava等の言語との違いとして、それらを囲う丸括弧`()`が必要ないということです。

```go:for.go
package main

import "fmt"

func main() {
	sum := 0
	for i := 0; i < 10; i++ {
		sum += i
	}
	fmt.Println(sum)
}
```
```:Run
45
```

### 4.2. For continued

初期化と後処理は任意です。
不要な場合は`;`のみ記述します。

```diff go:for-continued.go
package main

import "fmt"

func main() {
	sum := 1
-	for i := 0; i < 10; i++ {
+	for ; sum < 1000; {
		sum += sum
	}
	fmt.Println(sum)
}
```
```:Run
1024
```

### 4.3. For is Go's "while"

なんなら、`;`を省略することだってできてしまいます。つまりC言語等のwhile文はGo言語におけるfor文であるのです。

```diff go:for-is-gos-while.go
package main

import "fmt"

func main() {
	sum := 1
-	for ; sum < 1000; {
+	for sum < 1000 {
		sum += sum
	}
	fmt.Println(sum)
}
```
```:Run
1024
```

### 4.4. Forever

条件式を省略すると無限ループとなります。

```go:forever.go
package main

func main() {
	for {
	}
}
```
```:Run
```

### 4.5. If

if文にはfor文同様に丸括弧`()`が必要ありません。

```go:if.go
package main

import (
	"fmt"
	"math"
)

func sqrt(x float64) string {
	if x < 0 {
		return sqrt(-x) + "i"
	}
	return fmt.Sprint(math.Sqrt(x))
}

func main() {
	fmt.Println(sqrt(2), sqrt(-4))
}
```
```:Run
1.4142135623730951 2i
```

### 4.6. If with a short statement

for文のように条件式の前に簡単な文を書くことができます。

```go:if-with-a-short-statement
package main

import (
	"fmt"
	"math"
)

func pow(x, n, lim float64) float64 {
	if v := math.Pow(x, n); v < lim {
		return v
	}
	return lim
}

func main() {
	fmt.Println(
		pow(3, 2, 10),
		pow(3, 3, 20),
	)
}
```
```:Run
9 20
```

### 4.7. If and else

if文で宣言された変数はelse文でも用いることができます。

```go:if-and-else.go
package main

import (
	"fmt"
	"math"
)

func pow(x, n, lim float64) float64 {
	if v := math.Pow(x, n); v < lim {
		return v
	} else {
		fmt.Printf("%g >= %g\n", v, lim)
	}
	// can't use v here, though
	return lim
}

func main() {
	fmt.Println(
		pow(3, 2, 10),
		pow(3, 3, 20),
	)
}
```
```:Run
27 >= 20
9 20
```

なお、main関数の`Println`は先にpow関数が実行されてから実行されるため、pow関数の`Printf`が先に実行され、その後`9 20`が出力されています。

### 4.8. Exercise: Loops and Functions

関数とループを利用して平方根を計算してみます。数値`x`が与えられた時に幾つかの`z`を推測し、`z^2`がどれだけ`x`に近づいたかに応じて`z`を調節できます。

```go:exercise-loops-and-functions.go
package main

import (
	"fmt"
)

func Sqrt(x float64) float64 {
}

func main() {
	fmt.Println(Sqrt(2))
}
```

#### 4.8.1. 解答例

`math`パッケージをインポートして出力を比較してみました。

```diff go:exercise-loops-and-functions.go
package main

import (
	"fmt"
+	"math"
)

func Sqrt(x float64) float64 {
+	z := 1.0
+	for i := 0; i < 10; i++ {
+		z -= (z*z - x) / (2*z)
+	}
+	return z
}

func main() {
	fmt.Println(Sqrt(2))
+	fmt.Println(math.Sqrt(2))
}
```

### 4.9. Switch

switch文は`if-else`文を短く書くことができます。

他言語と比較してGo言語は、選択された`case`のみ実行しその他の`case`は実行されません。また、最後に必要な`break`も自動で提供されるため必要ありません。
さらに、`case`は**定数でも整数でもなくて良い**のです。

```go:switch.go
package main

import (
	"fmt"
	"runtime"
)

func main() {
	fmt.Print("Go runs on ")
	switch os := runtime.GOOS; os {
	case "darwin":
		fmt.Println("OS X.")
	case "linux":
		fmt.Println("Linux.")
	default:
		// freebsd, openbsd,
		// plan9, windows...
		fmt.Printf("%s.\n", os)
	}
}
```
```:Run
Go runs on Linux.
```

### 4.10. Switch evaluation order

`case`文は上から下に評価されるため、条件が一致するとそこで`switch`文は終了(自動的にbreak)します。

```go:switch-evaluation-order.go
package main

import (
	"fmt"
	"time"
)

func main() {
	fmt.Println("When's Saturday?")
	today := time.Now().Weekday()
	switch time.Saturday {
	case today + 0:
		fmt.Println("Today.")
	case today + 1:
		fmt.Println("Tomorrow.")
	case today + 2:
		fmt.Println("In two days.")
	default:
		fmt.Println("Too far away.")
	}
}
```
```:Run
When's Saturday?
Too far away.
```

この実行結果を見るに、火曜日から金曜日の間であるようです。果たして`2009-11-10 23:00:00 UTC`は何曜日なのでしょうか。

### 4.11. Switch with no condition

条件のない`switch`文は、`switch true`と書くことと同様です。これを利用して、長くなりがちな`if-then-else`をシンプルに表現することが可能となります。

```go:switch-with-no-condition.go
package main

import (
	"fmt"
	"time"
)

func main() {
	t := time.Now()
	switch {
	case t.Hour() < 12:
		fmt.Println("Good morning!")
	case t.Hour() < 17:
		fmt.Println("Good afternoon.")
	default:
		fmt.Println("Good evening.")
	}
}
```
```:Run
Good evening.
```

`2009-11-10 23:00:00 UTC`は23時なので`Good evening.`が出力されています。

### 4.12. Defer

`defer`文は元の関数の実行を`return`するまで遅延させます。関数の引数はすぐに評価されますが、実行そのものは`return`されるまで実行されません。

```go:defer.go
package main

import "fmt"

func main() {
	defer fmt.Println("world")

	fmt.Println("hello")
}
```
```:Run
hello
world
```

### 4.13. Stacking defers

`defer`を複数回利用した場合、それらはスタックされます。元の関数が`return`されると、 `LIFO`(last-in-first-out)の順で実行されます。

```go:defer-multi.go
package main

import "fmt"

func main() {
	fmt.Println("counting")

	for i := 0; i < 10; i++ {
		defer fmt.Println(i)
	}

	fmt.Println("done")
}
```
```:Run
counting
done
9
8
7
6
5
4
3
2
1
0
```

### 4.14. まとめ
- `for`文には`()`が必要ない
- 初期化と後処理を省略し、他言語のwhile文同様に扱うことが可能
- 条件式を省略すると無限ループする
- `if`文にも`()`は必要ない
- 条件式の前に簡単な文を記述可能
- そこで得た変数はelse文でも利用可能
- `switch`文には`break`が必要ない
- `case`文は**定数でも整数でもなくて良い**
- `case`文は上から順に評価され、一致するとそこで終了する
- 条件のない`switch`文は`if-then-else`をシンプルに表現可能
- `defer`文は元の関数の実行を`return`するまで遅延させる
- 複数回利用した場合、それらはスタックされ、`LIFO`で実行される

:::
:::details More types: structs, slices, and maps.

## 5. More types: structs, slices, and maps.

### 5.1. Pointers

変数`T`のポインタは、`*T`型で、ゼロ値は`nil`です。

ポインタ演算はありません。

主な仕様は以下のプログラムを見ればわかりますが、`&`でアドレスを引き出し、`*`でそのアドレスが指す変数を表します。

```go:pointers.go
package main

import "fmt"

func main() {
	i, j := 42, 2701

	p := &i         // point to i
	fmt.Println(*p) // read i through the pointer
	*p = 21         // set i through the pointer
	fmt.Println(i)  // see the new value of i

	p = &j         // point to j
	*p = *p / 37   // divide j through the pointer
	fmt.Println(j) // see the new value of j
}
```
```:Run
42
21
73
```

### 5.2. Structs

`struct`(構造体)は、`field`(フィールド)の集まりです。

```go:structs.go
package main

import "fmt"

type Vertex struct {
	X int
	Y int
}

func main() {
	fmt.Println(Vertex{1, 2})
}
```
```:Run
{1 2}
```

### 5.3. Struct Fields

`field`は`.`を用いてアクセスします。

```go:struct-fields.go
package main

import "fmt"

type Vertex struct {
	X int
	Y int
}

func main() {
	v := Vertex{1, 2}
	v.X = 4
	fmt.Println(v.X)
}
```
```:Run
4
```

### 5.4. Pointers to structs

`struct`の`field`はポインタを用いてアクセスすることもできます。

```go:struct-pointers.go
package main

import "fmt"

type Vertex struct {
	X int
	Y int
}

func main() {
	v := Vertex{1, 2}
	p := &v
	p.X = 1e9
	fmt.Println(v)
}
```
```:Run
{1000000000 2}
```

### 5.5. Struct Literals

`:`で特定の値だけ初期化することができます。また、先頭に`&`をつけると新たな`struct`へのポインタが代入されます。

```go:strut-literals.go
package main

import "fmt"

type Vertex struct {
	X, Y int
}

var (
	v1 = Vertex{1, 2}  // has type Vertex
	v2 = Vertex{X: 1}  // Y:0 is implicit
	v3 = Vertex{}      // X:0 and Y:0
	p  = &Vertex{1, 2} // has type *Vertex
)

func main() {
	fmt.Println(v1, p, v2, v3)
}
```
```:Run
{1 2} &{1 2} {1 0} {0 0}
```

`v2`では`X`のみ初期化しているので`Y`はゼロ値(0)となりました。

### 5.6. Arrays

`[n]T`型は、型`T`の`n`個の変数の`array`(配列)を表します。

例えばint型の10個の配列を作るには次のようにします。
`var n [10]int`
配列の長さは型の一部なので変更することはできません。

```go:array.go
package main

import "fmt"

func main() {
	var a [2]string
	a[0] = "Hello"
	a[1] = "World"
	fmt.Println(a[0], a[1])
	fmt.Println(a)

	primes := [6]int{2, 3, 5, 7, 11, 13}
	fmt.Println(primes)
}
```
```:Run
Hello World
[Hello World]
[2 3 5 7 11 13]
```

配列そのものを出力する際は配列ということがわかるように`[]`がついています。

### 5.7. Slices

型`[]T`は型`T`の`slice`(スライス)を表します。
配列は固定長ですがスライスは可変長です。

```go:slices.go
package main

import "fmt"

func main() {
	primes := [6]int{2, 3, 5, 7, 11, 13}

	var s []int = primes[1:4]
	fmt.Println(s)
}
```
```:Run
[3 5 7]
```

このプログラムの場合、`primes`の要素1から3が選択されています。`Python`と同じような記法みたいです。

### 5.8. Slices are like references to arrays

`slice`は**配列へのポインタ**(参照)です。つまりスライスの要素を変更すると配列の要素も変更されますし、同一の要素を共有しているスライスも変更されます。

```go:slice-pointers.go
package main

import "fmt"

func main() {
	names := [4]string{
		"John",
		"Paul",
		"George",
		"Ringo",
	}
	fmt.Println(names)

	a := names[0:2]
	b := names[1:3]
	fmt.Println(a, b)

	b[0] = "XXX"
	fmt.Println(a, b)
	fmt.Println(names)
}
```
```:Run
[John Paul George Ringo]
[John Paul] [Paul George]
[John XXX] [XXX George]
[John XXX George Ringo]
```

これを利用すると特定のユーザー名が変更された時一箇所変更を加えるだけで全体を変更できるので便利そうです。

### 5.9. Slice literals

`[3]bool{true, false, false}`これは配列リテラルですが、
`[]bool{true, false, false}`これは上記と同様の配列を作成し、それを参照するスライスを作成します。

```go:slice-literals.go
package main

import "fmt"

func main() {
	q := []int{2, 3, 5, 7, 11, 13}
	fmt.Println(q)

	r := []bool{true, false, true, true, false, true}
	fmt.Println(r)

	s := []struct {
		i int
		b bool
	}{
		{2, true},
		{3, false},
		{5, true},
		{7, true},
		{11, false},
		{13, true},
	}
	fmt.Println(s)
}
```
```:Run
[2 3 5 7 11 13]
[true false true true false true]
[{2 true} {3 false} {5 true} {7 true} {11 false} {13 true}]
```

### 5.10. Slice defaults

次の配列において`var n [10]int`
`n[0:10] n[:10] n[0:] n[:]`これらは等価です。
これもPythonにあります。

```go:slice-bounds.go
package main

import "fmt"

func main() {
	s := []int{2, 3, 5, 7, 11, 13}

	s = s[1:4]
	fmt.Println(s)

	s = s[:2]
	fmt.Println(s)

	s = s[1:]
	fmt.Println(s)
}
```
```:Run
[3 5 7]
[3 5]
[5]
```

### 5.11. Slice length and capacity

スライスは`length`(長さ)と`capacity`(容量)の両方を持ちます。長さは要素の数で、容量はスライスの最初の要素から数えて元の配列の要素数です。
スライス`s`の長さは`len(s)`容量は`cap(s)`という関数で求められます。

```go:slice-len-cap.go
package main

import "fmt"

func main() {
	s := []int{2, 3, 5, 7, 11, 13}
	printSlice(s)

	// Slice the slice to give it zero length.
	s = s[:0]
	printSlice(s)

	// Extend its length.
	s = s[:4]
	printSlice(s)

	// Drop its first two values.
	s = s[2:]
	printSlice(s)
}

func printSlice(s []int) {
	fmt.Printf("len=%d cap=%d %v\n", len(s), cap(s), s)
}
```
```:Run
len=6 cap=6 [2 3 5 7 11 13]
len=0 cap=6 []
len=4 cap=6 [2 3 5 7]
len=2 cap=4 [5 7]
```

それではスライスを拡張し、容量を超えてしまった場合はどうなるのでしょうか。

```diff go:slice-len-cap.go
package main

import "fmt"

func main() {
	s := []int{2, 3, 5, 7, 11, 13}
	printSlice(s)

	// Slice the slice to give it zero length.
	s = s[:0]
	printSlice(s)

	// Extend its length.
	s = s[:4]
	printSlice(s)

	// Drop its first two values.
	s = s[2:]
	printSlice(s)
	
+	s = append(s, 1, 2, 3)
+	printSlice(s)
}

func printSlice(s []int) {
	fmt.Printf("len=%d cap=%d %v\n", len(s), cap(s), s)
}
```
```diff :Run
len=6 cap=6 [2 3 5 7 11 13]
len=0 cap=6 []
len=4 cap=6 [2 3 5 7]
len=2 cap=4 [5 7]
+len=5 cap=8 [5 7 1 2 3]
```

長さは書いてあるとおり拡張されましたが、なんと容量は2倍に増加しています。これはGo言語の仕様で、スライスが拡張された場合は基本的に容量が2倍確保されるようです。
これはスライスの容量が超過する毎に新たな領域を確保しているため、1ずつ増やしていては効率が悪いためです。

### 5.12. Nil slices

2回目ですが、スライスのゼロ値は`nil`です。
長さも容量も共に`0`で、当然ですが元となる配列もありません。
```go:nil-slices.go
package main

import "fmt"

func main() {
	var s []int
	fmt.Println(s, len(s), cap(s))
	if s == nil {
		fmt.Println("nil!")
	}
}
```
```:Run
[] 0 0
nil!
```

### 5.13. Creating a slice with make

`make`関数を使用することで、ゼロ化された配列を割り当て、それを指すスライスを返します。
第二引数に長さ、第三引数に容量を指定することができます。

```go:making-slices.go
package main

import "fmt"

func main() {
	a := make([]int, 5)
	printSlice("a", a)

	b := make([]int, 0, 5)
	printSlice("b", b)

	c := b[:2]
	printSlice("c", c)

	d := c[2:5]
	printSlice("d", d)
}

func printSlice(s string, x []int) {
	fmt.Printf("%s len=%d cap=%d %v\n",
		s, len(x), cap(x), x)
}
```
```:Run
a len=5 cap=5 [0 0 0 0 0]
b len=0 cap=5 []
c len=2 cap=5 [0 0]
d len=3 cap=3 [0 0 0]
```

### 5.14. Slices of slices

スライスの中にはスライスを含め他の型を入れることができます。

```go:slices-of-slice.go
package main

import (
	"fmt"
	"strings"
)

func main() {
	// Create a tic-tac-toe board.
	board := [][]string{
		[]string{"_", "_", "_"},
		[]string{"_", "_", "_"},
		[]string{"_", "_", "_"},
	}

	// The players take turns.
	board[0][0] = "X"
	board[2][2] = "O"
	board[1][2] = "X"
	board[1][0] = "O"
	board[0][2] = "X"

	for i := 0; i < len(board); i++ {
		fmt.Printf("%s\n", strings.Join(board[i], " "))
	}
}
```
```:Run
X _ X
O _ X
_ _ O
```

### 5.15. Appending to a slice

先ほども利用しましたが、スライスに新たな要素を追加するときは、`append`関数を利用します。
要素を追加した際に容量をオーバーしてしまったときは新たに配列を割り当て直しスライスはそこを指すようになります。

```go:append.go
package main

import "fmt"

func main() {
	var s []int
	printSlice(s)

	// append works on nil slices.
	s = append(s, 0)
	printSlice(s)

	// The slice grows as needed.
	s = append(s, 1)
	printSlice(s)

	// We can add more than one element at a time.
	s = append(s, 2, 3, 4)
	printSlice(s)
}

func printSlice(s []int) {
	fmt.Printf("len=%d cap=%d %v\n", len(s), cap(s), s)
}
```
```:Run
len=0 cap=0 []
len=1 cap=1 [0]
len=2 cap=2 [0 1]
len=5 cap=6 [0 1 2 3 4]
```

### 5.16. Range

`range`は配列やスライスを反復処理する際に利用し、二つの値を返します。
例えばスライスの場合、一つは`index`、もう一つはそのインデックスの要素のコピーです。

```go:range.go
package main

import "fmt"

var pow = []int{1, 2, 4, 8, 16, 32, 64, 128}

func main() {
	for i, v := range pow {
		fmt.Printf("2**%d = %d\n", i, v)
	}
}
```
```:Run
2**0 = 1
2**1 = 2
2**2 = 4
2**3 = 8
2**4 = 16
2**5 = 32
2**6 = 64
2**7 = 128
```

### 5.17. Range continued

インデックスや値は`_`で捨てることができます。
また、二つ目の変数を省略することでインデックスだけを取り出すこともできます。

```go:range-continued.go
package main

import "fmt"

func main() {
	pow := make([]int, 10)
	for i := range pow {
		pow[i] = 1 << uint(i) // == 2**i
	}
	for _, value := range pow {
		fmt.Printf("%d\n", value)
	}
}
```
```:Run
1
2
4
8
16
32
64
128
256
512
```

### 5.18. Exercise: Slices

`Pic`関数を実装してみます。
長さ`dy`のスライスに各要素が八ビットのuint型で長さ`dx`のスライスを割り当てたものを返す必要があります。実行すると画像が表示されます。
使用する関数の例として以下のようなものがおすすめされていました。
`(x+y)/2`、`x*y`、`x^y`

```go:exercise-slices.go
package main

import "golang.org/x/tour/pic"

func Pic(dx, dy int) [][]uint8 {
}

func main() {
	pic.Show(Pic)
}
```

#### 5.18.1. 解答例

```diff go:exercise-slices.go
package main

import "golang.org/x/tour/pic"

func Pic(dx, dy int) [][]uint8 {
+	ss := make([][]uint8, dy)
+		for y := 0; y < dy; y++ {
+			s := make([]uint8, dx)
+			for x := 0; x < dx; x++ {
+				s[x] = uint8((x + y) / 2)
+			}
+			ss[y] = s
+		}
+	return ss
}

func main() {
	pic.Show(Pic)
}

```
**Run**
![](/images/398bb7daebb893/2023-03-21-05-22-25.png)

### 5.19. Maps

`map`はキーと値を関連付け、ゼロ値は`nil`で、キーを持たず追加することもできません。
`make`関数は指定された型のマップを初期化し、使用可能な状態で返します。


```go:maps.go
package main

import "fmt"

type Vertex struct {
	Lat, Long float64
}

var m map[string]Vertex

func main() {
	m = make(map[string]Vertex)
	m["Bell Labs"] = Vertex{
		40.68433, -74.39967,
	}
	fmt.Println(m["Bell Labs"])
}
```
```:Run
{40.68433 -74.39967}
```

### 5.20. Map literals

mapリテラルはstructリテラルと似ていますが、`key`(キー)が必要です。

```go:map-literals.go
package main

import "fmt"

type Vertex struct {
	Lat, Long float64
}

var m = map[string]Vertex{
	"Bell Labs": Vertex{
		40.68433, -74.39967,
	},
	"Google": Vertex{
		37.42202, -122.08408,
	},
}

func main() {
	fmt.Println(m)
}
```
```:Run
map[Bell Labs:{40.68433 -74.39967} Google:{37.42202 -122.08408}]
```

### 5.21. Map literals continued

mapに渡すトップレベルの型が単純な型名の場合、リテラルの要素から推定できるため省略が可能です。

```go:map-literals-continued
package main

import "fmt"

type Vertex struct {
	Lat, Long float64
}

var m = map[string]Vertex{
	"Bell Labs": {40.68433, -74.39967},
	"Google":    {37.42202, -122.08408},
}

func main() {
	fmt.Println(m)
}
```
```:Run
map[Bell Labs:{40.68433 -74.39967} Google:{37.42202 -122.08408}]
```

### 5.22. Mutating Maps

mapのキーに対する要素が存在する場合は二つ目の要素(boolean)で判断し、存在すれば`true`存在しなければ`false`で確認できます。

```go:mutating-maps.go
package main

import "fmt"

func main() {
	m := make(map[string]int)

	m["Answer"] = 42
	fmt.Println("The value:", m["Answer"])

	m["Answer"] = 48
	fmt.Println("The value:", m["Answer"])

	delete(m, "Answer")
	fmt.Println("The value:", m["Answer"])

	v, ok := m["Answer"]
	fmt.Println("The value:", v, "Present?", ok)
}
```
```:Run
The value: 42
The value: 48
The value: 0
The value: 0 Present? false
```

### 5.23. Exercise: Maps

今回は`WordCount`関数を実装します。
`string`で渡される文章の各単語の出現回数のmapを返します。
`wc.Test`関数はテストスイートを実行し成功か否かを出力します。

```go:exercise-maps.go
package main

import (
	"golang.org/x/tour/wc"
)

func WordCount(s string) map[string]int {
	return map[string]int{"x": 1}
}

func main() {
	wc.Test(WordCount)
}
```

#### 5.23.1. 解答例

```diff go:exercise-maps.go
package main

import (
	"golang.org/x/tour/wc"
+	"strings"
)

func WordCount(s string) map[string]int {
+	m := make(map[string]int)
+	str := strings.Fields(s)
+	for _, v := range str {
+		m[v]++
+	}
+	return m
- return map[string]int{"x": 1}
}

func main() {
	wc.Test(WordCount)
}
```
```:Run
PASS
 f("I am learning Go!") = 
  map[string]int{"Go!":1, "I":1, "am":1, "learning":1}
PASS
 f("The quick brown fox jumped over the lazy dog.") = 
  map[string]int{"The":1, "brown":1, "dog.":1, "fox":1, "jumped":1, "lazy":1, "over":1, "quick":1, "the":1}
PASS
 f("I ate a donut. Then I ate another donut.") = 
  map[string]int{"I":2, "Then":1, "a":1, "another":1, "ate":2, "donut.":2}
PASS
 f("A man a plan a canal panama.") = 
  map[string]int{"A":1, "a":2, "canal":1, "man":1, "panama.":1, "plan":1}
```

### 5.24. Function values

関数も変数の一種ですので、関数に関数を渡したり、関数値は関数の引数に取ることも、戻り値としても利用できます。

とてもややこしいですね。

```go:function-values.go
package main

import (
	"fmt"
	"math"
)

func compute(fn func(float64, float64) float64) float64 {
	return fn(3, 4)
}

func main() {
	hypot := func(x, y float64) float64 {
		return math.Sqrt(x*x + y*y)
	}
	fmt.Println(hypot(5, 12))

	fmt.Println(compute(hypot))
	fmt.Println(compute(math.Pow))
}
```
```:Run
13
5
81
```

### 5.25. Function closures

Golangの関数は`closure`(クロージャ)で、関数内で定義された関数であり、外部変数を参照することができます。これにより状態を保持し、カプセル化出来ます。Javaとかやったことある人はわかりやすいかもしれません。

```go:function-closures.go
package main

import "fmt"

func adder() func(int) int {
	sum := 0
	return func(x int) int {
		sum += x
		return sum
	}
}

func main() {
	pos, neg := adder(), adder()
	for i := 0; i < 10; i++ {
		fmt.Println(
			pos(i),
			neg(-2*i),
		)
	}
}
```
```:Run
0 0
1 -2
3 -6
6 -12
10 -20
15 -30
21 -42
28 -56
36 -72
45 -90
```

### 5.26. Exercise: Fibonacci closure

フィボナッチ関数を実装します。
この関数は連続するフィボナッチ数を返す関数(クロージャ)を返します。

```go:exercise-fibonacci-closure.go
package main

import "fmt"

// fibonacci is a function that returns
// a function that returns an int.
func fibonacci() func() int {
}

func main() {
	f := fibonacci()
	for i := 0; i < 10; i++ {
		fmt.Println(f())
	}
}
```

#### 5.26.1. 解答例
```diff go:exercise-fibonacci-closure.go
package main

import "fmt"

// fibonacci is a function that returns
// a function that returns an int.
func fibonacci() func() int {
	a, b := 0, 1
	return func() int {
		a, b = b, a+b
		return a
	}	
}

func main() {
	f := fibonacci()
	for i := 0; i < 10; i++ {
		fmt.Println(f())
	}
}
```
```:Run
21
​
1
1
2
3
5
8
13
21
34
55
```

### 5.27. まとめ

- ポインタのゼロ値は`nil`
- `&`でアドレス、`*`で変数を表す
- ポインタ演算は無い
- `struct`は`field`の集まり
- `field`は`.`を用いてアクセスする
- `:`で特定の値だけ初期化することができる
- 先頭に`&`をつけると新たな`struct`へのポインタが代入される
- `[n]T`型は、型`T`の`n`個の変数の`array`を表す
- 配列の長さを変えることはできない
- 型`[]T`は型`T`の`slice`を表す
- スライスは可変長
- `slice`は**配列へのポインタ**にすぎない
- スライス`s`の長さは`len(s)`容量は`cap(s)`という関数を利用する
- `make`関数でスライスを返し、長さと容量を指定できる
- スライスの中にはスライスを含め他の型を入れることができる
- スライスに要素を追加するときは`append`関数を利用する
- `range`で配列やスライスを反復処理可能
- 一つは`index`、もう一つは要素のコピーを返す
- `_`に代入することで値を切り捨てることが可能
- `map`はキーと値を関連付ける
- `make`関数で指定された型のマップを初期化し、使用可能な状態で返す
- mapリテラルは`key`が必要
- mapに渡す型名が単純な型名の場合省略可能
- キーに対する要素が存在するかは二つ目の要素(boolean)で判断
- 関数も変数の一種
- Goの関数は`closure`で、カプセル化が可能となっている

:::
:::details 5
:::
:::details 6
:::