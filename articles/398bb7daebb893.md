---
title: "A Tour of Go ã‚’ã‚„ã£ã¦ã¿ãŸ"
emoji: "ğŸ’»"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: [Go, Tutorial,]
published: false
---

## 1. æ¦‚è¦

Goè¨€èªãŒåˆ©ç”¨ã•ã‚Œã¦ã„ã‚‹ãƒ—ãƒ­ãƒ€ã‚¯ãƒˆãŒå¢—åŠ å‚¾å‘ã®ã‚ˆã†ãªã®ã§å…¬å¼ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ã§ã‚‚ã‚ã‚‹ã€ŒA Tour of Goã€ã§ã‚ã‚‹ç¨‹åº¦å­¦ã‚“ã§ã¿ãŸã„ã¨æ€ã†ã€‚

:::details Welcome!

## 2. Welcome!

ä»Šå›ã¯1å›ç›®ã®ã€ŒWelcome!ã€ã‚’è¡Œã†ã€‚

https://go-tour-jp.appspot.com/welcome/1

### 2.1. Wello World

ã¨ã‚Šã‚ãˆãšå®Ÿè¡Œã—ã¦ã¿ãªã•ã„ã¨è¨€ã‚ã‚ŒãŸã®ã§å®Ÿè¡Œã—ã¾ã—ãŸã€‚

```go:hello.go
package main

import "fmt"

func main() {
	fmt.Println("Hello, ä¸–ç•Œ")
}
```
```:Run
Hello, ä¸–ç•Œ
```

æ—¥æœ¬èªè¨³ç‰ˆãªã®ã§ã€ŒHello, Worldã€ã§ã¯ãªãã€ŒHello, ä¸–ç•Œã€ã¨ãªã£ã¦ã„ã¾ã™ãŒã€ãã‚Œã¯æ°—ã«ã™ã‚‹å•é¡Œã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚

### 2.2. Go local

Go Tourã¯è‹±èªä»¥å¤–ã«ã‚‚ãƒ‰ã‚¤ãƒ„èªã‚„ä¸­å›½èªã€éŸ“å›½èªç­‰ã€ã•ã¾ã–ã¾ãªè¨€èªã§åˆ©ç”¨ã§ãã‚‹ã‚ˆã†ã§ã™ã€‚

### 2.3. Go offline

ä»Šå›ç§ã¯ãƒ–ãƒ©ã‚¦ã‚¶ä¸Šã§ã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œã—ã¾ã™ãŒã€ãƒ­ãƒ¼ã‚«ãƒ«ã§å®Ÿè¡Œã™ã‚‹æ–¹æ³•ãŒè¨˜è¼‰ã•ã‚Œã¦ã„ã¾ã—ãŸã€‚

[Goã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã¨ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«](https://go.dev/dl/)ã‚’ã—ã¦ã€`go tool tour`ã¨å®Ÿè¡Œã™ã‚‹ã“ã¨ã§ãƒ­ãƒ¼ã‚«ãƒ«ã§ã®å®Ÿè¡ŒãŒå¯èƒ½ã«ãªã‚‹ã‚ˆã†ã§ã™ã€‚

### 2.4. The Go Playground

ãƒ–ãƒ©ã‚¦ã‚¶ä¸Šã§å®Ÿè¡Œã™ã‚‹æ™‚ã¯å¸¸ã«`2009-11-10 23:00:00 UTC`ã‚‰ã—ã„ã§ã™ã€‚ã“ã‚Œã§åŒä¸€ã®å®Ÿè¡Œçµæœã‚’å¾—ã‚‹ã“ã¨ãŒå®¹æ˜“ã«ãªã‚‹ã‚“ã§ã™ã­ã€‚å®Ÿè¡Œçµæœã«ã‚‚ç¾ã‚Œã¦ã„ã¾ã™ã€‚
å¸¸ã«æœ€æ–°ã®å®‰å®šãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’åˆ©ç”¨ã§ãã‚‹ãã†ãªã®ã§ä½•ã‚‚è€ƒãˆãšãƒ–ãƒ©ã‚¦ã‚¶ä¸Šã§å®Ÿè¡Œã™ã‚Œã°è‰¯ã•ãã†ã§ã™ã€‚

```go:sandbox.go
package main

import (
	"fmt"
	"time"
)

func main() {
	fmt.Println("Welcome to the playground!")

	fmt.Println("The time is", time.Now())
}
```

```:Run
Welcome to the playground!
The time is 2009-11-10 23:00:00 +0000 UTC m=+0.000000001
```

### 2.5. ã¾ã¨ã‚
- Go Playgroundã¨ã„ã†Webã‚µãƒ¼ãƒ“ã‚¹ã®ã‚µãƒ³ãƒ‰ãƒœãƒƒã‚¯ã‚¹å†…ã§ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã€ãƒªãƒ³ã‚¯ã€å®Ÿè¡Œã—ã¦ã„ã‚‹
- å¸¸ã«`2009-11-10 23:00:00 UTC`ã§ã‚ã‚‹

:::

:::details Packages, variables, and functions.

## 3. Packages, variables, and functions.

### 3.1. Packages

Goã¯`package`(ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸)ã§æ§‹æˆã•ã‚Œã¦ãŠã‚Šã€ã“ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯`main`ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã§ã™ã€‚
ä»Šå›ã¯`fmt`ã¨`math/rand`ã®äºŒã¤ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’`import`(ã‚¤ãƒ³ãƒãƒ¼ãƒˆ)ã—ã¦ã„ã¾ã™ã€‚

```go:packages.go
package main

import (
	"fmt"
	"math/rand"
)

func main() {
	fmt.Println("My favorite number is", rand.Intn(10))
}
```

```:Run
My favorite number is 7
```

Go Playgroundã§ã¯æ™‚åˆ»ãŒä¸€å®šãªã®ã§ãƒ©ãƒ³ãƒ€ãƒ ã«ç”Ÿæˆã™ã‚‹`rand`ã‚’ç”¨ã„ã¦ã‚‚å‡ºåŠ›çµæœã¯ä¸€å®š(7)ã¨ãªã‚Šã¾ã™ã€‚



### 3.2. Imports

æ‹¬å¼§ã§ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚’ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã—ã¦ãŠã‚Šã€å…¬å¼ã«ã‚‚ã“ã®è¨˜æ³•(factored import statement)ãŒæ¨å¥¨ã•ã‚Œã¦ã„ã¾ã™ãŒã€ä»¥ä¸‹ã®ã‚ˆã†ã«è¤‡æ•°ã®importæ–‡ã‚’æ›¸ãã“ã¨ã‚‚ã§ãã¾ã™ã€‚

`import "fmt"`
`import "math"`

```go:imports.go
package main

import (
	"fmt"
	"math"
)

func main() {
	fmt.Printf("Now you have %g problems.\n", math.Sqrt(7))
}
```
```:Run
Now you have 2.6457513110645907 problems.
```

### 3.3. Exported names

ä¸€æ–‡å­—ç›®ãŒå¤§æ–‡å­—ã§å§‹ã¾ã‚‹åå‰ã¯å¤–éƒ¨ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‹ã‚‰å‚ç…§ã•ã‚ŒãŸåå‰(exported name)ã§ã™ã€‚
åå¯¾ã«å°æ–‡å­—ã§å§‹ã¾ã‚‹åå‰ã¯å¤–éƒ¨ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‹ã‚‰å‚ç…§ã™ã‚‹ã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚

ãã“ã§ä»¥ä¸‹ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’å®Ÿè¡Œã—ã¦ã¿ã¾ã™ã€‚

```go:exported-names.go
package main

import (
	"fmt"
	"math"
)

func main() {
	fmt.Println(math.pi)
}
```

```:Run
./prog.go:9:19: undefined: math.pi
```

ã‚¨ãƒ©ãƒ¼ãŒå‡ºã¦ã—ã¾ã„ã¾ã—ãŸã€‚ã€Œmath.piã¯å®šç¾©ã•ã‚Œã¦ãªã„ã‚ˆã€ã¨è¨€ã‚ã‚Œã¦ã„ã¾ã™ã€‚å°æ–‡å­—ã‹ã‚‰å§‹ã¾ã‚‹åå‰ã¯å¤–éƒ¨ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‹ã‚‰å‚ç…§ã§ãã¾ã›ã‚“ã®ã§ã€`math.Pi`ã«å¤‰æ›´ã—ã¦å®Ÿè¡Œã—ã¦ã¿ã¾ã™ã€‚

```diff go:exported-names.go
package main

import (
	"fmt"
	"math"
)

func main() {
-	fmt.Println(math.pi)
+	fmt.Println(math.Pi)
}
```
```:Run
3.141592653589793
```

ç„¡äº‹ã«å††å‘¨ç‡ãŒè¡¨ç¤ºã•ã‚Œã¾ã—ãŸã€‚

### 3.4. Functions

ä»Šå›ã®addé–¢æ•°ã¯intå‹ã®2ã¤ã®å¼•æ•°ã‚’å–ã‚Šã¾ã™ãŒã€**å¤‰æ•°åã®å¾Œã‚**ã«å‹åã‚’è¨˜è¿°ã—ã¾ã™ã€‚

```go:functions.go
package main

import "fmt"

func add(x int, y int) int {
	return x + y
}

func main() {
	fmt.Println(add(42, 13))
}
```
```:Run
55
```

42+13ã®çµæœãŒå‡ºåŠ›ã•ã‚Œã¦ã„ã¾ã™ã€‚

### 3.5. Functions continued

è¤‡æ•°ã®å¼•æ•°ã®å‹ãŒåŒä¸€ã®æ™‚ã€æœ€å¾Œã ã‘æ®‹ã—ã¦çœç•¥ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ä¾‹ãˆã°ä»¥ä¸‹ã®ã‚ˆã†ã«ã—ã¾ã™ã€‚

```diff go:functions-continued.go
package main

import "fmt"

-func add(x int, y int) int {
+func add(x, y int) int {
	return x + y
}

func main() {
	fmt.Println(add(42, 13))
}
```
```:Run
55
```

### 3.6. Multiple results

è¤‡æ•°ã®æˆ»ã‚Šå€¤ã‚’è¿”ã™ã“ã¨ã‚‚ã§ãã¾ã™ã€‚
ä»¥ä¸‹ã®swapé–¢æ•°ã‚’è¦‹ã¦ã¿ã¾ã™ã€‚

```go:multiple-result.go
package main

import "fmt"

func swap(x, y string) (string, string) {
	return y, x
}

func main() {
	a, b := swap("hello", "world")
	fmt.Println(a, b)
}
```
```:Run
world hello
```

ã“ã®ã‚ˆã†ã«ã€a,bãã‚Œãã‚Œã«ä»£å…¥ã§ãã¦ã„ã¾ã™ã€‚

### 3.7. Named return values

æˆ»ã‚Šå€¤ã¨ãªã‚‹å¤‰æ•°ã«åå‰ã‚’ã¤ã‘ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã†ã™ã‚‹ã“ã¨ã§ã€returnã®ã¿ã§å€¤ã‚’è¿”ã™ã“ã¨ãŒã§ãã¾ã™ã€‚('naked return')
é•·ã„é–¢æ•°ã§åˆ©ç”¨ã™ã‚‹ã¨èª­ã¿ã‚„ã™ã•ã«æ‚ªå½±éŸ¿ã‚’ä¸ãˆã‚‹ãŸã‚ã€çŸ­ã„é–¢æ•°ã§ã®ã¿åˆ©ç”¨ã™ã‚‹ã¹ãã§ã™ã€‚

```go:named-result.go
package main

import "fmt"

func split(sum int) (x, y int) {
	x = sum * 4 / 9
	y = sum - x
	return
}

func main() {
	fmt.Println(split(17))
}
```
```:Run
7 10
```

### 3.8. Variables

varæ–‡ã¯å¤‰æ•°ã‚’å®£è¨€ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã‚Œã‚‚é–¢æ•°ã®å¼•æ•°ã¨åŒæ§˜ã«å¤‰æ•°åã®æœ€å¾Œã«å‹åã‚’æ›¸ãã“ã¨ã§çœç•¥ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

```go:variables.go
package main

import "fmt"

var c, python, java bool

func main() {
	var i int
	fmt.Println(i, c, python, java)
}
```
```:Run
0 false false false
```

ã”è¦§ã®é€šã‚Šã€é–¢æ•°å†…ã§ã‚‚varæ–‡ã¯åˆ©ç”¨å¯èƒ½ã§ã™ã€‚

### 3.9. Variables with initializers

varã§å¤‰æ•°ã‚’å®£è¨€ã™ã‚‹éš›ã«åˆæœŸåŒ–å­ã‚’ä¸ãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ãã®éš›ã€å‹ã‚’çœç•¥ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

```go:variables-with-initializers.go
package main

import "fmt"

var i, j int = 1, 2

func main() {
	var c, python, java = true, false, "no!"
	fmt.Println(i, j, c, python, java)
}
```
```:Run
1 2 true false no!
```
mainé–¢æ•°å†…ã§ã¯å‹å®£è¨€ã‚’ã—ã¦ã„ã¾ã›ã‚“ãŒã€åˆæœŸåŒ–å­ã‚’ä¸ãˆã‚‹ã“ã¨ã§å‹•ä½œã•ã›ã‚‹ã“ã¨ãŒã§ãã¦ã„ã¾ã™ã€‚

### 3.10. Short variable declarations

**é–¢æ•°ã®ä¸­ã§ã®ã¿**varã®ä»£ã‚ã‚Šã«`:=`ã®æš—é»™çš„ãªå‹å®£è¨€ãŒå¯èƒ½ã§ã™ã€‚

```go short-variable-declarations
package main

import "fmt"

func main() {
	var i, j int = 1, 2
	k := 3
	c, python, java := true, false, "no!"

	fmt.Println(i, j, k, c, python, java)
}
```
```:Run
1 2 3 true false no!
```

### 3.11. Basic types

åŸºæœ¬å‹ã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™ã€‚
```
bool

string

int  int8  int16  int32  int64
uint uint8 uint16 uint32 uint64 uintptr

byte // uint8 ã®åˆ¥å

rune // int32 ã®åˆ¥å
     // Unicode ã®ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’è¡¨ã™

float32 float64

complex64 complex128
```

```go:basec-types.go
package main

import (
	"fmt"
	"math/cmplx"
)

var (
	ToBe   bool       = false
	MaxInt uint64     = 1<<64 - 1
	z      complex128 = cmplx.Sqrt(-5 + 12i)
)

func main() {
	fmt.Printf("Type: %T Value: %v\n", ToBe, ToBe)
	fmt.Printf("Type: %T Value: %v\n", MaxInt, MaxInt)
	fmt.Printf("Type: %T Value: %v\n", z, z)
}
```
```:Run
Type: bool Value: false
Type: uint64 Value: 18446744073709551615
Type: complex128 Value: (2+3i)
```

### 3.12. Zero values

å¤‰æ•°ã«åˆæœŸå€¤ã‚’ä¸ãˆãªã„å ´åˆã¯ã‚¼ãƒ­å€¤ãŒä»£å…¥ã•ã‚Œã¾ã™ã€‚

| å‹       | å€¤    |
| -------- | ----- |
| æ•´æ•°å‹   | 0     |
| boolå‹   | false |
| stringå‹ | ""    |

```go:zero.go
package main

import "fmt"

func main() {
	var i int
	var f float64
	var b bool
	var s string
	fmt.Printf("%v %v %v %q\n", i, f, b, s)
}
```
```:Run
0 0 false ""
```

### 3.13. Type conversions

å¤‰æ•°`v`ã€å‹`T`ãŒã‚ã£ãŸæ™‚ã€å‹å¤‰æ›ã¯`T(v)`ã§è¡Œã„ã¾ã™ã€‚

```go:type-conversions.go
package main

import (
	"fmt"
	"math"
)

func main() {
	var x, y int = 3, 4
	var f float64 = math.Sqrt(float64(x*x + y*y))
	var z uint = uint(f)
	fmt.Println(x, y, z)
}
```
```:Run
3 4 5
```

ä»¥ä¸‹ã®ã‚ˆã†ã«çœç•¥ã—ã¦è¨˜è¿°ã™ã‚‹ã“ã¨ã‚‚å¯èƒ½ã§ã™ã€‚

```diff go:type-conversions.go
package main

import (
	"fmt"
	"math"
)

func main() {
-	var x, y int = 3, 4
-	var f float64 = math.Sqrt(float64(x*x + y*y))
-	var z uint = uint(f)
+	x, y  := 3, 4
+	f := math.Sqrt(float64(x*x + y*y))
+	z := uint(f)
	fmt.Println(x, y, z)
}
```
```:Run
3 4 5
```

### 3.14. Type inference

`:=`ã‚„`var =`ç­‰ã§æ˜ç¤ºçš„ãªå‹ã‚’æŒ‡å®šã—ãªã„å ´åˆã€å³å´ã®å¤‰æ•°ã‹ã‚‰å‹æ¨è«–ã•ã‚Œã¾ã™ã€‚
å‹ã‚’æŒ‡å®šã—ãªã„æ•°å€¤ã§ã‚ã‚‹å ´åˆã€å³å´ã®å®šæ•°ã®ç²¾åº¦ã«åŸºã¥ã„ã¦`int`,`float64`,`complex128`ã«ãªã‚Šã¾ã™ã€‚

```go:type-inference.go
package main

import "fmt"

func main() {
	v := 42 // change me!
	fmt.Printf("v is of type %T\n", v)
}
```
```:Run
v is of type int
```

`change me!`ã¨è¨€ã‚ã‚Œã¦ã„ã‚‹ãŸã‚3.14ã«å¤‰æ›´ã—ã¦ã¿ã¾ã™ã€‚


```diff go:type-inference.go
package main

import "fmt"

func main() {
-	v := 42 // change me!
+	v := 3.14 // change me!
	fmt.Printf("v is of type %T\n", v)
}
```
```:Run
v is of type float64
```

`int`ã‹ã‚‰`float64`ã«å¤‰ã‚ã‚Šã¾ã—ãŸã€‚

### 3.15. Constants

å®šæ•°ã¯`const`ã‚’ç”¨ã„ã¦å®£è¨€ã—ã¾ã™ã€‚
ãŸã ã—ã€`:=`ã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚

```go:constants.go
package main

import "fmt"

const Pi = 3.14

func main() {
	const World = "ä¸–ç•Œ"
	fmt.Println("Hello", World)
	fmt.Println("Happy", Pi, "Day")

	const Truth = true
	fmt.Println("Go rules?", Truth)
}
```
```:Run
Hello ä¸–ç•Œ
Happy 3.14 Day
Go rules? true
```

### 3.16. Numeric Constants

å‹ã®ãªã„å®šæ•°ã¯çŠ¶æ³ã«ã‚ˆã‚Šå¿…è¦ãªå‹ã‚’å–ã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚
ä»¥ä¸‹ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ã¯ã€`Big`,`Small`ã«å‹ãŒå®£è¨€ã•ã‚Œã¦ã„ãªã„ãŸã‚è¨ˆç®—çµæœã«ã‚ˆã‚Šå‹ãŒå¤‰ã‚ã£ã¦ã„ã¾ã™ã€‚

```go:numeric-constants.go
package main

import "fmt"

const (
	// Create a huge number by shifting a 1 bit left 100 places.
	// In other words, the binary number that is 1 followed by 100 zeroes.
	Big = 1 << 100
	// Shift it right again 99 places, so we end up with 1<<1, or 2.
	Small = Big >> 99
)

func needInt(x int) int { return x*10 + 1 }
func needFloat(x float64) float64 {
	return x * 0.1
}

func main() {
	fmt.Println(needInt(Small))
	fmt.Println(needFloat(Small))
	fmt.Println(needFloat(Big))
}
```

 ```:Run
21
0.2
1.2676506002282295e+29
 ```

ã¡ãªã¿ã«`needInt(Big)`ã¨ã™ã‚‹ã¨å€¤ãŒå¤§ãããªã‚Šã™ãã¦ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ã—ã‚¨ãƒ©ãƒ¼ãŒå‡ºåŠ›ã•ã‚Œã¾ã—ãŸã€‚

### 3.17. ã¾ã¨ã‚

- Goã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯`package`(ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸)ã§æ§‹æˆã•ã‚Œã‚‹
- ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆã¯mainé–¢æ•°
- å¤§æ–‡å­—ã‹ã‚‰å§‹ã¾ã‚‹åå‰**ã ã‘**å¤–éƒ¨ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‹ã‚‰å‚ç…§ã™ã‚‹ã“ã¨ãŒã§ãã‚‹
- å‹åã¯**å¤‰æ•°ã®å¾Œã‚**ã«æ›¸ã
- åŒã˜å‹ã®å¼•æ•°ãŒè¤‡æ•°ã‚ã‚‹å ´åˆå‹ã®å®£è¨€ã¯æœ€å¾Œã ã‘æ®‹ã—ã¦çœç•¥ã§ãã‚‹
- æˆ»ã‚Šå€¤ã¨ãªã‚‹å¤‰æ•°ã«åå‰ã‚’ã¤ã‘ã‚‹ã“ã¨ã§returnæ–‡ã«ä½•ã‚‚æ›¸ã‹ãªãã¦ã‚‚è‰¯ããªã‚‹
- varæ–‡ã§å¤‰æ•°ã‚’å®£è¨€ã—ã€å¼•æ•°åŒæ§˜å‹å®£è¨€ã®çœç•¥ã‚‚å¯èƒ½
- åˆæœŸåŒ–å­ã‚’ä¸ãˆã‚‹ã“ã¨ã§å‹å®£è¨€ã‚’çœç•¥å¯èƒ½
- **é–¢æ•°ã®ä¸­ã§ã®ã¿**varã®ä»£ã‚ã‚Šã«`:=`ã®æš—é»™çš„ãªå‹å®£è¨€ãŒå¯èƒ½ã§ã™
- å¤‰æ•°ã«åˆæœŸå€¤ã‚’ä¸ãˆãªã„å ´åˆã€ã‚¼ãƒ­å€¤ãŒä»£å…¥ã•ã‚Œã‚‹
- å¤‰æ•°`v`ã€å‹`T`ãŒã‚ã£ãŸæ™‚ã€å‹å¤‰æ›ã¯`T(v)`ã§è¡Œã†
- `:=`ã‚„`var =`ç­‰ã§æ˜ç¤ºçš„ãªå‹ã‚’æŒ‡å®šã—ãªã„å ´åˆã€å³å´ã®å¤‰æ•°ã‹ã‚‰å‹æ¨è«–ã•ã‚Œã‚‹
- å®šæ•°ã¯`const`ã‚’ç”¨ã„ã¦å®£è¨€ã§ãã‚‹ãŒã€`:=`ã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ã¯ã§ããªã„ã€‚
- å‹ã®ãªã„å®šæ•°ã¯çŠ¶æ³ã«ã‚ˆã‚Šå¿…è¦ãªå‹ã‚’å–ã‚‹ã“ã¨ã«ãªã‚‹ã€‚

:::

:::details Flow control statements: for, if, else, switch and defer

## 4. Flow control statements: for, if, else, switch and defer

### 4.1. For

foræ–‡ã¯ã€åˆæœŸåŒ–ãƒ»æ¡ä»¶ãƒ»å¾Œå‡¦ç†ã®3ã¤ã®å‡¦ç†ãŒã‚»ãƒŸã‚³ãƒ­ãƒ³`;`ã§åˆ†ã‘ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚
Cã‚„Javaç­‰ã®è¨€èªã¨ã®é•ã„ã¨ã—ã¦ã€ãã‚Œã‚‰ã‚’å›²ã†ä¸¸æ‹¬å¼§`()`ãŒå¿…è¦ãªã„ã¨ã„ã†ã“ã¨ã§ã™ã€‚

```go:for.go
package main

import "fmt"

func main() {
	sum := 0
	for i := 0; i < 10; i++ {
		sum += i
	}
	fmt.Println(sum)
}
```
```:Run
45
```

### 4.2. For continued

åˆæœŸåŒ–ã¨å¾Œå‡¦ç†ã¯ä»»æ„ã§ã™ã€‚
ä¸è¦ãªå ´åˆã¯`;`ã®ã¿è¨˜è¿°ã—ã¾ã™ã€‚

```diff go:for-continued.go
package main

import "fmt"

func main() {
	sum := 1
-	for i := 0; i < 10; i++ {
+	for ; sum < 1000; {
		sum += sum
	}
	fmt.Println(sum)
}
```
```:Run
1024
```

### 4.3. For is Go's "while"

ãªã‚“ãªã‚‰ã€`;`ã‚’çœç•¥ã™ã‚‹ã“ã¨ã ã£ã¦ã§ãã¦ã—ã¾ã„ã¾ã™ã€‚ã¤ã¾ã‚ŠCè¨€èªç­‰ã®whileæ–‡ã¯Goè¨€èªã«ãŠã‘ã‚‹foræ–‡ã§ã‚ã‚‹ã®ã§ã™ã€‚

```diff go:for-is-gos-while.go
package main

import "fmt"

func main() {
	sum := 1
-	for ; sum < 1000; {
+	for sum < 1000 {
		sum += sum
	}
	fmt.Println(sum)
}
```
```:Run
1024
```

### 4.4. Forever

æ¡ä»¶å¼ã‚’çœç•¥ã™ã‚‹ã¨ç„¡é™ãƒ«ãƒ¼ãƒ—ã¨ãªã‚Šã¾ã™ã€‚

```go:forever.go
package main

func main() {
	for {
	}
}
```
```:Run
```

### 4.5. If

ifæ–‡ã«ã¯foræ–‡åŒæ§˜ã«ä¸¸æ‹¬å¼§`()`ãŒå¿…è¦ã‚ã‚Šã¾ã›ã‚“ã€‚

```go:if.go
package main

import (
	"fmt"
	"math"
)

func sqrt(x float64) string {
	if x < 0 {
		return sqrt(-x) + "i"
	}
	return fmt.Sprint(math.Sqrt(x))
}

func main() {
	fmt.Println(sqrt(2), sqrt(-4))
}
```
```:Run
1.4142135623730951 2i
```

### 4.6. If with a short statement

foræ–‡ã®ã‚ˆã†ã«æ¡ä»¶å¼ã®å‰ã«ç°¡å˜ãªæ–‡ã‚’æ›¸ãã“ã¨ãŒã§ãã¾ã™ã€‚

```go:if-with-a-short-statement
package main

import (
	"fmt"
	"math"
)

func pow(x, n, lim float64) float64 {
	if v := math.Pow(x, n); v < lim {
		return v
	}
	return lim
}

func main() {
	fmt.Println(
		pow(3, 2, 10),
		pow(3, 3, 20),
	)
}
```
```:Run
9 20
```

### 4.7. If and else

ifæ–‡ã§å®£è¨€ã•ã‚ŒãŸå¤‰æ•°ã¯elseæ–‡ã§ã‚‚ç”¨ã„ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

```go:if-and-else.go
package main

import (
	"fmt"
	"math"
)

func pow(x, n, lim float64) float64 {
	if v := math.Pow(x, n); v < lim {
		return v
	} else {
		fmt.Printf("%g >= %g\n", v, lim)
	}
	// can't use v here, though
	return lim
}

func main() {
	fmt.Println(
		pow(3, 2, 10),
		pow(3, 3, 20),
	)
}
```
```:Run
27 >= 20
9 20
```

ãªãŠã€mainé–¢æ•°ã®`Println`ã¯å…ˆã«powé–¢æ•°ãŒå®Ÿè¡Œã•ã‚Œã¦ã‹ã‚‰å®Ÿè¡Œã•ã‚Œã‚‹ãŸã‚ã€powé–¢æ•°ã®`Printf`ãŒå…ˆã«å®Ÿè¡Œã•ã‚Œã€ãã®å¾Œ`9 20`ãŒå‡ºåŠ›ã•ã‚Œã¦ã„ã¾ã™ã€‚

### 4.8. Exercise: Loops and Functions

é–¢æ•°ã¨ãƒ«ãƒ¼ãƒ—ã‚’åˆ©ç”¨ã—ã¦å¹³æ–¹æ ¹ã‚’è¨ˆç®—ã—ã¦ã¿ã¾ã™ã€‚æ•°å€¤`x`ãŒä¸ãˆã‚‰ã‚ŒãŸæ™‚ã«å¹¾ã¤ã‹ã®`z`ã‚’æ¨æ¸¬ã—ã€`z^2`ãŒã©ã‚Œã ã‘`x`ã«è¿‘ã¥ã„ãŸã‹ã«å¿œã˜ã¦`z`ã‚’èª¿ç¯€ã§ãã¾ã™ã€‚

```go:exercise-loops-and-functions.go
package main

import (
	"fmt"
)

func Sqrt(x float64) float64 {
}

func main() {
	fmt.Println(Sqrt(2))
}
```

#### 4.8.1. è§£ç­”ä¾‹

`math`ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¦å‡ºåŠ›ã‚’æ¯”è¼ƒã—ã¦ã¿ã¾ã—ãŸã€‚

```diff go:exercise-loops-and-functions.go
package main

import (
	"fmt"
+	"math"
)

func Sqrt(x float64) float64 {
+	z := 1.0
+	for i := 0; i < 10; i++ {
+		z -= (z*z - x) / (2*z)
+	}
+	return z
}

func main() {
	fmt.Println(Sqrt(2))
+	fmt.Println(math.Sqrt(2))
}
```

### 4.9. Switch

switchæ–‡ã¯`if-else`æ–‡ã‚’çŸ­ãæ›¸ãã“ã¨ãŒã§ãã¾ã™ã€‚

ä»–è¨€èªã¨æ¯”è¼ƒã—ã¦Goè¨€èªã¯ã€é¸æŠã•ã‚ŒãŸ`case`ã®ã¿å®Ÿè¡Œã—ãã®ä»–ã®`case`ã¯å®Ÿè¡Œã•ã‚Œã¾ã›ã‚“ã€‚ã¾ãŸã€æœ€å¾Œã«å¿…è¦ãª`break`ã‚‚è‡ªå‹•ã§æä¾›ã•ã‚Œã‚‹ãŸã‚å¿…è¦ã‚ã‚Šã¾ã›ã‚“ã€‚
ã•ã‚‰ã«ã€`case`ã¯**å®šæ•°ã§ã‚‚æ•´æ•°ã§ã‚‚ãªãã¦è‰¯ã„**ã®ã§ã™ã€‚

```go:switch.go
package main

import (
	"fmt"
	"runtime"
)

func main() {
	fmt.Print("Go runs on ")
	switch os := runtime.GOOS; os {
	case "darwin":
		fmt.Println("OS X.")
	case "linux":
		fmt.Println("Linux.")
	default:
		// freebsd, openbsd,
		// plan9, windows...
		fmt.Printf("%s.\n", os)
	}
}
```
```:Run
Go runs on Linux.
```

### 4.10. Switch evaluation order

`case`æ–‡ã¯ä¸Šã‹ã‚‰ä¸‹ã«è©•ä¾¡ã•ã‚Œã‚‹ãŸã‚ã€æ¡ä»¶ãŒä¸€è‡´ã™ã‚‹ã¨ãã“ã§`switch`æ–‡ã¯çµ‚äº†(è‡ªå‹•çš„ã«break)ã—ã¾ã™ã€‚

```go:switch-evaluation-order.go
package main

import (
	"fmt"
	"time"
)

func main() {
	fmt.Println("When's Saturday?")
	today := time.Now().Weekday()
	switch time.Saturday {
	case today + 0:
		fmt.Println("Today.")
	case today + 1:
		fmt.Println("Tomorrow.")
	case today + 2:
		fmt.Println("In two days.")
	default:
		fmt.Println("Too far away.")
	}
}
```
```:Run
When's Saturday?
Too far away.
```

ã“ã®å®Ÿè¡Œçµæœã‚’è¦‹ã‚‹ã«ã€ç«æ›œæ—¥ã‹ã‚‰é‡‘æ›œæ—¥ã®é–“ã§ã‚ã‚‹ã‚ˆã†ã§ã™ã€‚æœãŸã—ã¦`2009-11-10 23:00:00 UTC`ã¯ä½•æ›œæ—¥ãªã®ã§ã—ã‚‡ã†ã‹ã€‚

### 4.11. Switch with no condition

æ¡ä»¶ã®ãªã„`switch`æ–‡ã¯ã€`switch true`ã¨æ›¸ãã“ã¨ã¨åŒæ§˜ã§ã™ã€‚ã“ã‚Œã‚’åˆ©ç”¨ã—ã¦ã€é•·ããªã‚ŠãŒã¡ãª`if-then-else`ã‚’ã‚·ãƒ³ãƒ—ãƒ«ã«è¡¨ç¾ã™ã‚‹ã“ã¨ãŒå¯èƒ½ã¨ãªã‚Šã¾ã™ã€‚

```go:switch-with-no-condition.go
package main

import (
	"fmt"
	"time"
)

func main() {
	t := time.Now()
	switch {
	case t.Hour() < 12:
		fmt.Println("Good morning!")
	case t.Hour() < 17:
		fmt.Println("Good afternoon.")
	default:
		fmt.Println("Good evening.")
	}
}
```
```:Run
Good evening.
```

`2009-11-10 23:00:00 UTC`ã¯23æ™‚ãªã®ã§`Good evening.`ãŒå‡ºåŠ›ã•ã‚Œã¦ã„ã¾ã™ã€‚

### 4.12. Defer

`defer`æ–‡ã¯å…ƒã®é–¢æ•°ã®å®Ÿè¡Œã‚’`return`ã™ã‚‹ã¾ã§é…å»¶ã•ã›ã¾ã™ã€‚é–¢æ•°ã®å¼•æ•°ã¯ã™ãã«è©•ä¾¡ã•ã‚Œã¾ã™ãŒã€å®Ÿè¡Œãã®ã‚‚ã®ã¯`return`ã•ã‚Œã‚‹ã¾ã§å®Ÿè¡Œã•ã‚Œã¾ã›ã‚“ã€‚

```go:defer.go
package main

import "fmt"

func main() {
	defer fmt.Println("world")

	fmt.Println("hello")
}
```
```:Run
hello
world
```

### 4.13. Stacking defers

`defer`ã‚’è¤‡æ•°å›åˆ©ç”¨ã—ãŸå ´åˆã€ãã‚Œã‚‰ã¯ã‚¹ã‚¿ãƒƒã‚¯ã•ã‚Œã¾ã™ã€‚å…ƒã®é–¢æ•°ãŒ`return`ã•ã‚Œã‚‹ã¨ã€ `LIFO`(last-in-first-out)ã®é †ã§å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚

```go:defer-multi.go
package main

import "fmt"

func main() {
	fmt.Println("counting")

	for i := 0; i < 10; i++ {
		defer fmt.Println(i)
	}

	fmt.Println("done")
}
```
```:Run
counting
done
9
8
7
6
5
4
3
2
1
0
```

### 4.14. ã¾ã¨ã‚
- `for`æ–‡ã«ã¯`()`ãŒå¿…è¦ãªã„
- åˆæœŸåŒ–ã¨å¾Œå‡¦ç†ã‚’çœç•¥ã—ã€ä»–è¨€èªã®whileæ–‡åŒæ§˜ã«æ‰±ã†ã“ã¨ãŒå¯èƒ½
- æ¡ä»¶å¼ã‚’çœç•¥ã™ã‚‹ã¨ç„¡é™ãƒ«ãƒ¼ãƒ—ã™ã‚‹
- `if`æ–‡ã«ã‚‚`()`ã¯å¿…è¦ãªã„
- æ¡ä»¶å¼ã®å‰ã«ç°¡å˜ãªæ–‡ã‚’è¨˜è¿°å¯èƒ½
- ãã“ã§å¾—ãŸå¤‰æ•°ã¯elseæ–‡ã§ã‚‚åˆ©ç”¨å¯èƒ½
- `switch`æ–‡ã«ã¯`break`ãŒå¿…è¦ãªã„
- `case`æ–‡ã¯**å®šæ•°ã§ã‚‚æ•´æ•°ã§ã‚‚ãªãã¦è‰¯ã„**
- `case`æ–‡ã¯ä¸Šã‹ã‚‰é †ã«è©•ä¾¡ã•ã‚Œã€ä¸€è‡´ã™ã‚‹ã¨ãã“ã§çµ‚äº†ã™ã‚‹
- æ¡ä»¶ã®ãªã„`switch`æ–‡ã¯`if-then-else`ã‚’ã‚·ãƒ³ãƒ—ãƒ«ã«è¡¨ç¾å¯èƒ½
- `defer`æ–‡ã¯å…ƒã®é–¢æ•°ã®å®Ÿè¡Œã‚’`return`ã™ã‚‹ã¾ã§é…å»¶ã•ã›ã‚‹
- è¤‡æ•°å›åˆ©ç”¨ã—ãŸå ´åˆã€ãã‚Œã‚‰ã¯ã‚¹ã‚¿ãƒƒã‚¯ã•ã‚Œã€`LIFO`ã§å®Ÿè¡Œã•ã‚Œã‚‹

:::
:::details More types: structs, slices, and maps.

## 5. More types: structs, slices, and maps.

### 5.1. Pointers

å¤‰æ•°`T`ã®ãƒã‚¤ãƒ³ã‚¿ã¯ã€`*T`å‹ã§ã€ã‚¼ãƒ­å€¤ã¯`nil`ã§ã™ã€‚

ãƒã‚¤ãƒ³ã‚¿æ¼”ç®—ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚

ä¸»ãªä»•æ§˜ã¯ä»¥ä¸‹ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’è¦‹ã‚Œã°ã‚ã‹ã‚Šã¾ã™ãŒã€`&`ã§ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å¼•ãå‡ºã—ã€`*`ã§ãã®ã‚¢ãƒ‰ãƒ¬ã‚¹ãŒæŒ‡ã™å¤‰æ•°ã‚’è¡¨ã—ã¾ã™ã€‚

```go:pointers.go
package main

import "fmt"

func main() {
	i, j := 42, 2701

	p := &i         // point to i
	fmt.Println(*p) // read i through the pointer
	*p = 21         // set i through the pointer
	fmt.Println(i)  // see the new value of i

	p = &j         // point to j
	*p = *p / 37   // divide j through the pointer
	fmt.Println(j) // see the new value of j
}
```
```:Run
42
21
73
```

### 5.2. Structs

`struct`(æ§‹é€ ä½“)ã¯ã€`field`(ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰)ã®é›†ã¾ã‚Šã§ã™ã€‚

```go:structs.go
package main

import "fmt"

type Vertex struct {
	X int
	Y int
}

func main() {
	fmt.Println(Vertex{1, 2})
}
```
```:Run
{1 2}
```

### 5.3. Struct Fields

`field`ã¯`.`ã‚’ç”¨ã„ã¦ã‚¢ã‚¯ã‚»ã‚¹ã—ã¾ã™ã€‚

```go:struct-fields.go
package main

import "fmt"

type Vertex struct {
	X int
	Y int
}

func main() {
	v := Vertex{1, 2}
	v.X = 4
	fmt.Println(v.X)
}
```
```:Run
4
```

### 5.4. Pointers to structs

`struct`ã®`field`ã¯ãƒã‚¤ãƒ³ã‚¿ã‚’ç”¨ã„ã¦ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚

```go:struct-pointers.go
package main

import "fmt"

type Vertex struct {
	X int
	Y int
}

func main() {
	v := Vertex{1, 2}
	p := &v
	p.X = 1e9
	fmt.Println(v)
}
```
```:Run
{1000000000 2}
```

### 5.5. Struct Literals

`:`ã§ç‰¹å®šã®å€¤ã ã‘åˆæœŸåŒ–ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã¾ãŸã€å…ˆé ­ã«`&`ã‚’ã¤ã‘ã‚‹ã¨æ–°ãŸãª`struct`ã¸ã®ãƒã‚¤ãƒ³ã‚¿ãŒä»£å…¥ã•ã‚Œã¾ã™ã€‚

```go:strut-literals.go
package main

import "fmt"

type Vertex struct {
	X, Y int
}

var (
	v1 = Vertex{1, 2}  // has type Vertex
	v2 = Vertex{X: 1}  // Y:0 is implicit
	v3 = Vertex{}      // X:0 and Y:0
	p  = &Vertex{1, 2} // has type *Vertex
)

func main() {
	fmt.Println(v1, p, v2, v3)
}
```
```:Run
{1 2} &{1 2} {1 0} {0 0}
```

`v2`ã§ã¯`X`ã®ã¿åˆæœŸåŒ–ã—ã¦ã„ã‚‹ã®ã§`Y`ã¯ã‚¼ãƒ­å€¤(0)ã¨ãªã‚Šã¾ã—ãŸã€‚

### 5.6. Arrays

`[n]T`å‹ã¯ã€å‹`T`ã®`n`å€‹ã®å¤‰æ•°ã®`array`(é…åˆ—)ã‚’è¡¨ã—ã¾ã™ã€‚

ä¾‹ãˆã°intå‹ã®10å€‹ã®é…åˆ—ã‚’ä½œã‚‹ã«ã¯æ¬¡ã®ã‚ˆã†ã«ã—ã¾ã™ã€‚
`var n [10]int`
é…åˆ—ã®é•·ã•ã¯å‹ã®ä¸€éƒ¨ãªã®ã§å¤‰æ›´ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚

```go:array.go
package main

import "fmt"

func main() {
	var a [2]string
	a[0] = "Hello"
	a[1] = "World"
	fmt.Println(a[0], a[1])
	fmt.Println(a)

	primes := [6]int{2, 3, 5, 7, 11, 13}
	fmt.Println(primes)
}
```
```:Run
Hello World
[Hello World]
[2 3 5 7 11 13]
```

é…åˆ—ãã®ã‚‚ã®ã‚’å‡ºåŠ›ã™ã‚‹éš›ã¯é…åˆ—ã¨ã„ã†ã“ã¨ãŒã‚ã‹ã‚‹ã‚ˆã†ã«`[]`ãŒã¤ã„ã¦ã„ã¾ã™ã€‚

### 5.7. Slices

å‹`[]T`ã¯å‹`T`ã®`slice`(ã‚¹ãƒ©ã‚¤ã‚¹)ã‚’è¡¨ã—ã¾ã™ã€‚
é…åˆ—ã¯å›ºå®šé•·ã§ã™ãŒã‚¹ãƒ©ã‚¤ã‚¹ã¯å¯å¤‰é•·ã§ã™ã€‚

```go:slices.go
package main

import "fmt"

func main() {
	primes := [6]int{2, 3, 5, 7, 11, 13}

	var s []int = primes[1:4]
	fmt.Println(s)
}
```
```:Run
[3 5 7]
```

ã“ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®å ´åˆã€`primes`ã®è¦ç´ 1ã‹ã‚‰3ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã™ã€‚`Python`ã¨åŒã˜ã‚ˆã†ãªè¨˜æ³•ã¿ãŸã„ã§ã™ã€‚

### 5.8. Slices are like references to arrays

`slice`ã¯**é…åˆ—ã¸ã®ãƒã‚¤ãƒ³ã‚¿**(å‚ç…§)ã§ã™ã€‚ã¤ã¾ã‚Šã‚¹ãƒ©ã‚¤ã‚¹ã®è¦ç´ ã‚’å¤‰æ›´ã™ã‚‹ã¨é…åˆ—ã®è¦ç´ ã‚‚å¤‰æ›´ã•ã‚Œã¾ã™ã—ã€åŒä¸€ã®è¦ç´ ã‚’å…±æœ‰ã—ã¦ã„ã‚‹ã‚¹ãƒ©ã‚¤ã‚¹ã‚‚å¤‰æ›´ã•ã‚Œã¾ã™ã€‚

```go:slice-pointers.go
package main

import "fmt"

func main() {
	names := [4]string{
		"John",
		"Paul",
		"George",
		"Ringo",
	}
	fmt.Println(names)

	a := names[0:2]
	b := names[1:3]
	fmt.Println(a, b)

	b[0] = "XXX"
	fmt.Println(a, b)
	fmt.Println(names)
}
```
```:Run
[John Paul George Ringo]
[John Paul] [Paul George]
[John XXX] [XXX George]
[John XXX George Ringo]
```

ã“ã‚Œã‚’åˆ©ç”¨ã™ã‚‹ã¨ç‰¹å®šã®ãƒ¦ãƒ¼ã‚¶ãƒ¼åãŒå¤‰æ›´ã•ã‚ŒãŸæ™‚ä¸€ç®‡æ‰€å¤‰æ›´ã‚’åŠ ãˆã‚‹ã ã‘ã§å…¨ä½“ã‚’å¤‰æ›´ã§ãã‚‹ã®ã§ä¾¿åˆ©ãã†ã§ã™ã€‚

### 5.9. Slice literals

`[3]bool{true, false, false}`ã“ã‚Œã¯é…åˆ—ãƒªãƒ†ãƒ©ãƒ«ã§ã™ãŒã€
`[]bool{true, false, false}`ã“ã‚Œã¯ä¸Šè¨˜ã¨åŒæ§˜ã®é…åˆ—ã‚’ä½œæˆã—ã€ãã‚Œã‚’å‚ç…§ã™ã‚‹ã‚¹ãƒ©ã‚¤ã‚¹ã‚’ä½œæˆã—ã¾ã™ã€‚

```go:slice-literals.go
package main

import "fmt"

func main() {
	q := []int{2, 3, 5, 7, 11, 13}
	fmt.Println(q)

	r := []bool{true, false, true, true, false, true}
	fmt.Println(r)

	s := []struct {
		i int
		b bool
	}{
		{2, true},
		{3, false},
		{5, true},
		{7, true},
		{11, false},
		{13, true},
	}
	fmt.Println(s)
}
```
```:Run
[2 3 5 7 11 13]
[true false true true false true]
[{2 true} {3 false} {5 true} {7 true} {11 false} {13 true}]
```

### 5.10. Slice defaults

æ¬¡ã®é…åˆ—ã«ãŠã„ã¦`var n [10]int`
`n[0:10] n[:10] n[0:] n[:]`ã“ã‚Œã‚‰ã¯ç­‰ä¾¡ã§ã™ã€‚
ã“ã‚Œã‚‚Pythonã«ã‚ã‚Šã¾ã™ã€‚

```go:slice-bounds.go
package main

import "fmt"

func main() {
	s := []int{2, 3, 5, 7, 11, 13}

	s = s[1:4]
	fmt.Println(s)

	s = s[:2]
	fmt.Println(s)

	s = s[1:]
	fmt.Println(s)
}
```
```:Run
[3 5 7]
[3 5]
[5]
```

### 5.11. Slice length and capacity

ã‚¹ãƒ©ã‚¤ã‚¹ã¯`length`(é•·ã•)ã¨`capacity`(å®¹é‡)ã®ä¸¡æ–¹ã‚’æŒã¡ã¾ã™ã€‚é•·ã•ã¯è¦ç´ ã®æ•°ã§ã€å®¹é‡ã¯ã‚¹ãƒ©ã‚¤ã‚¹ã®æœ€åˆã®è¦ç´ ã‹ã‚‰æ•°ãˆã¦å…ƒã®é…åˆ—ã®è¦ç´ æ•°ã§ã™ã€‚
ã‚¹ãƒ©ã‚¤ã‚¹`s`ã®é•·ã•ã¯`len(s)`å®¹é‡ã¯`cap(s)`ã¨ã„ã†é–¢æ•°ã§æ±‚ã‚ã‚‰ã‚Œã¾ã™ã€‚

```go:slice-len-cap.go
package main

import "fmt"

func main() {
	s := []int{2, 3, 5, 7, 11, 13}
	printSlice(s)

	// Slice the slice to give it zero length.
	s = s[:0]
	printSlice(s)

	// Extend its length.
	s = s[:4]
	printSlice(s)

	// Drop its first two values.
	s = s[2:]
	printSlice(s)
}

func printSlice(s []int) {
	fmt.Printf("len=%d cap=%d %v\n", len(s), cap(s), s)
}
```
```:Run
len=6 cap=6 [2 3 5 7 11 13]
len=0 cap=6 []
len=4 cap=6 [2 3 5 7]
len=2 cap=4 [5 7]
```

ãã‚Œã§ã¯ã‚¹ãƒ©ã‚¤ã‚¹ã‚’æ‹¡å¼µã—ã€å®¹é‡ã‚’è¶…ãˆã¦ã—ã¾ã£ãŸå ´åˆã¯ã©ã†ãªã‚‹ã®ã§ã—ã‚‡ã†ã‹ã€‚

```diff go:slice-len-cap.go
package main

import "fmt"

func main() {
	s := []int{2, 3, 5, 7, 11, 13}
	printSlice(s)

	// Slice the slice to give it zero length.
	s = s[:0]
	printSlice(s)

	// Extend its length.
	s = s[:4]
	printSlice(s)

	// Drop its first two values.
	s = s[2:]
	printSlice(s)
	
+	s = append(s, 1, 2, 3)
+	printSlice(s)
}

func printSlice(s []int) {
	fmt.Printf("len=%d cap=%d %v\n", len(s), cap(s), s)
}
```
```diff :Run
len=6 cap=6 [2 3 5 7 11 13]
len=0 cap=6 []
len=4 cap=6 [2 3 5 7]
len=2 cap=4 [5 7]
+len=5 cap=8 [5 7 1 2 3]
```

é•·ã•ã¯æ›¸ã„ã¦ã‚ã‚‹ã¨ãŠã‚Šæ‹¡å¼µã•ã‚Œã¾ã—ãŸãŒã€ãªã‚“ã¨å®¹é‡ã¯2å€ã«å¢—åŠ ã—ã¦ã„ã¾ã™ã€‚ã“ã‚Œã¯Goè¨€èªã®ä»•æ§˜ã§ã€ã‚¹ãƒ©ã‚¤ã‚¹ãŒæ‹¡å¼µã•ã‚ŒãŸå ´åˆã¯åŸºæœ¬çš„ã«å®¹é‡ãŒ2å€ç¢ºä¿ã•ã‚Œã‚‹ã‚ˆã†ã§ã™ã€‚
ã“ã‚Œã¯ã‚¹ãƒ©ã‚¤ã‚¹ã®å®¹é‡ãŒè¶…éã™ã‚‹æ¯ã«æ–°ãŸãªé ˜åŸŸã‚’ç¢ºä¿ã—ã¦ã„ã‚‹ãŸã‚ã€1ãšã¤å¢—ã‚„ã—ã¦ã„ã¦ã¯åŠ¹ç‡ãŒæ‚ªã„ãŸã‚ã§ã™ã€‚

### 5.12. Nil slices

2å›ç›®ã§ã™ãŒã€ã‚¹ãƒ©ã‚¤ã‚¹ã®ã‚¼ãƒ­å€¤ã¯`nil`ã§ã™ã€‚
é•·ã•ã‚‚å®¹é‡ã‚‚å…±ã«`0`ã§ã€å½“ç„¶ã§ã™ãŒå…ƒã¨ãªã‚‹é…åˆ—ã‚‚ã‚ã‚Šã¾ã›ã‚“ã€‚
```go:nil-slices.go
package main

import "fmt"

func main() {
	var s []int
	fmt.Println(s, len(s), cap(s))
	if s == nil {
		fmt.Println("nil!")
	}
}
```
```:Run
[] 0 0
nil!
```

### 5.13. Creating a slice with make

`make`é–¢æ•°ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã§ã€ã‚¼ãƒ­åŒ–ã•ã‚ŒãŸé…åˆ—ã‚’å‰²ã‚Šå½“ã¦ã€ãã‚Œã‚’æŒ‡ã™ã‚¹ãƒ©ã‚¤ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚
ç¬¬äºŒå¼•æ•°ã«é•·ã•ã€ç¬¬ä¸‰å¼•æ•°ã«å®¹é‡ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

```go:making-slices.go
package main

import "fmt"

func main() {
	a := make([]int, 5)
	printSlice("a", a)

	b := make([]int, 0, 5)
	printSlice("b", b)

	c := b[:2]
	printSlice("c", c)

	d := c[2:5]
	printSlice("d", d)
}

func printSlice(s string, x []int) {
	fmt.Printf("%s len=%d cap=%d %v\n",
		s, len(x), cap(x), x)
}
```
```:Run
a len=5 cap=5 [0 0 0 0 0]
b len=0 cap=5 []
c len=2 cap=5 [0 0]
d len=3 cap=3 [0 0 0]
```

### 5.14. Slices of slices

ã‚¹ãƒ©ã‚¤ã‚¹ã®ä¸­ã«ã¯ã‚¹ãƒ©ã‚¤ã‚¹ã‚’å«ã‚ä»–ã®å‹ã‚’å…¥ã‚Œã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

```go:slices-of-slice.go
package main

import (
	"fmt"
	"strings"
)

func main() {
	// Create a tic-tac-toe board.
	board := [][]string{
		[]string{"_", "_", "_"},
		[]string{"_", "_", "_"},
		[]string{"_", "_", "_"},
	}

	// The players take turns.
	board[0][0] = "X"
	board[2][2] = "O"
	board[1][2] = "X"
	board[1][0] = "O"
	board[0][2] = "X"

	for i := 0; i < len(board); i++ {
		fmt.Printf("%s\n", strings.Join(board[i], " "))
	}
}
```
```:Run
X _ X
O _ X
_ _ O
```

### 5.15. Appending to a slice

å…ˆã»ã©ã‚‚åˆ©ç”¨ã—ã¾ã—ãŸãŒã€ã‚¹ãƒ©ã‚¤ã‚¹ã«æ–°ãŸãªè¦ç´ ã‚’è¿½åŠ ã™ã‚‹ã¨ãã¯ã€`append`é–¢æ•°ã‚’åˆ©ç”¨ã—ã¾ã™ã€‚
è¦ç´ ã‚’è¿½åŠ ã—ãŸéš›ã«å®¹é‡ã‚’ã‚ªãƒ¼ãƒãƒ¼ã—ã¦ã—ã¾ã£ãŸã¨ãã¯æ–°ãŸã«é…åˆ—ã‚’å‰²ã‚Šå½“ã¦ç›´ã—ã‚¹ãƒ©ã‚¤ã‚¹ã¯ãã“ã‚’æŒ‡ã™ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

```go:append.go
package main

import "fmt"

func main() {
	var s []int
	printSlice(s)

	// append works on nil slices.
	s = append(s, 0)
	printSlice(s)

	// The slice grows as needed.
	s = append(s, 1)
	printSlice(s)

	// We can add more than one element at a time.
	s = append(s, 2, 3, 4)
	printSlice(s)
}

func printSlice(s []int) {
	fmt.Printf("len=%d cap=%d %v\n", len(s), cap(s), s)
}
```
```:Run
len=0 cap=0 []
len=1 cap=1 [0]
len=2 cap=2 [0 1]
len=5 cap=6 [0 1 2 3 4]
```

### 5.16. Range

`range`ã¯é…åˆ—ã‚„ã‚¹ãƒ©ã‚¤ã‚¹ã‚’åå¾©å‡¦ç†ã™ã‚‹éš›ã«åˆ©ç”¨ã—ã€äºŒã¤ã®å€¤ã‚’è¿”ã—ã¾ã™ã€‚
ä¾‹ãˆã°ã‚¹ãƒ©ã‚¤ã‚¹ã®å ´åˆã€ä¸€ã¤ã¯`index`ã€ã‚‚ã†ä¸€ã¤ã¯ãã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®è¦ç´ ã®ã‚³ãƒ”ãƒ¼ã§ã™ã€‚

```go:range.go
package main

import "fmt"

var pow = []int{1, 2, 4, 8, 16, 32, 64, 128}

func main() {
	for i, v := range pow {
		fmt.Printf("2**%d = %d\n", i, v)
	}
}
```
```:Run
2**0 = 1
2**1 = 2
2**2 = 4
2**3 = 8
2**4 = 16
2**5 = 32
2**6 = 64
2**7 = 128
```

### 5.17. Range continued

ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚„å€¤ã¯`_`ã§æ¨ã¦ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
ã¾ãŸã€äºŒã¤ç›®ã®å¤‰æ•°ã‚’çœç•¥ã™ã‚‹ã“ã¨ã§ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã ã‘ã‚’å–ã‚Šå‡ºã™ã“ã¨ã‚‚ã§ãã¾ã™ã€‚

```go:range-continued.go
package main

import "fmt"

func main() {
	pow := make([]int, 10)
	for i := range pow {
		pow[i] = 1 << uint(i) // == 2**i
	}
	for _, value := range pow {
		fmt.Printf("%d\n", value)
	}
}
```
```:Run
1
2
4
8
16
32
64
128
256
512
```

### 5.18. Exercise: Slices

`Pic`é–¢æ•°ã‚’å®Ÿè£…ã—ã¦ã¿ã¾ã™ã€‚
é•·ã•`dy`ã®ã‚¹ãƒ©ã‚¤ã‚¹ã«å„è¦ç´ ãŒå…«ãƒ“ãƒƒãƒˆã®uintå‹ã§é•·ã•`dx`ã®ã‚¹ãƒ©ã‚¤ã‚¹ã‚’å‰²ã‚Šå½“ã¦ãŸã‚‚ã®ã‚’è¿”ã™å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚å®Ÿè¡Œã™ã‚‹ã¨ç”»åƒãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚
ä½¿ç”¨ã™ã‚‹é–¢æ•°ã®ä¾‹ã¨ã—ã¦ä»¥ä¸‹ã®ã‚ˆã†ãªã‚‚ã®ãŒãŠã™ã™ã‚ã•ã‚Œã¦ã„ã¾ã—ãŸã€‚
`(x+y)/2`ã€`x*y`ã€`x^y`

```go:exercise-slices.go
package main

import "golang.org/x/tour/pic"

func Pic(dx, dy int) [][]uint8 {
}

func main() {
	pic.Show(Pic)
}
```

#### 5.18.1. è§£ç­”ä¾‹

```diff go:exercise-slices.go
package main

import "golang.org/x/tour/pic"

func Pic(dx, dy int) [][]uint8 {
+	ss := make([][]uint8, dy)
+		for y := 0; y < dy; y++ {
+			s := make([]uint8, dx)
+			for x := 0; x < dx; x++ {
+				s[x] = uint8((x + y) / 2)
+			}
+			ss[y] = s
+		}
+	return ss
}

func main() {
	pic.Show(Pic)
}

```
**Run**
![](/images/398bb7daebb893/2023-03-21-05-22-25.png)

### 5.19. Maps

`map`ã¯ã‚­ãƒ¼ã¨å€¤ã‚’é–¢é€£ä»˜ã‘ã€ã‚¼ãƒ­å€¤ã¯`nil`ã§ã€ã‚­ãƒ¼ã‚’æŒãŸãšè¿½åŠ ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã›ã‚“ã€‚
`make`é–¢æ•°ã¯æŒ‡å®šã•ã‚ŒãŸå‹ã®ãƒãƒƒãƒ—ã‚’åˆæœŸåŒ–ã—ã€ä½¿ç”¨å¯èƒ½ãªçŠ¶æ…‹ã§è¿”ã—ã¾ã™ã€‚


```go:maps.go
package main

import "fmt"

type Vertex struct {
	Lat, Long float64
}

var m map[string]Vertex

func main() {
	m = make(map[string]Vertex)
	m["Bell Labs"] = Vertex{
		40.68433, -74.39967,
	}
	fmt.Println(m["Bell Labs"])
}
```
```:Run
{40.68433 -74.39967}
```

### 5.20. Map literals

mapãƒªãƒ†ãƒ©ãƒ«ã¯structãƒªãƒ†ãƒ©ãƒ«ã¨ä¼¼ã¦ã„ã¾ã™ãŒã€`key`(ã‚­ãƒ¼)ãŒå¿…è¦ã§ã™ã€‚

```go:map-literals.go
package main

import "fmt"

type Vertex struct {
	Lat, Long float64
}

var m = map[string]Vertex{
	"Bell Labs": Vertex{
		40.68433, -74.39967,
	},
	"Google": Vertex{
		37.42202, -122.08408,
	},
}

func main() {
	fmt.Println(m)
}
```
```:Run
map[Bell Labs:{40.68433 -74.39967} Google:{37.42202 -122.08408}]
```

### 5.21. Map literals continued

mapã«æ¸¡ã™ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ã®å‹ãŒå˜ç´”ãªå‹åã®å ´åˆã€ãƒªãƒ†ãƒ©ãƒ«ã®è¦ç´ ã‹ã‚‰æ¨å®šã§ãã‚‹ãŸã‚çœç•¥ãŒå¯èƒ½ã§ã™ã€‚

```go:map-literals-continued
package main

import "fmt"

type Vertex struct {
	Lat, Long float64
}

var m = map[string]Vertex{
	"Bell Labs": {40.68433, -74.39967},
	"Google":    {37.42202, -122.08408},
}

func main() {
	fmt.Println(m)
}
```
```:Run
map[Bell Labs:{40.68433 -74.39967} Google:{37.42202 -122.08408}]
```

### 5.22. Mutating Maps

mapã®ã‚­ãƒ¼ã«å¯¾ã™ã‚‹è¦ç´ ãŒå­˜åœ¨ã™ã‚‹å ´åˆã¯äºŒã¤ç›®ã®è¦ç´ (boolean)ã§åˆ¤æ–­ã—ã€å­˜åœ¨ã™ã‚Œã°`true`å­˜åœ¨ã—ãªã‘ã‚Œã°`false`ã§ç¢ºèªã§ãã¾ã™ã€‚

```go:mutating-maps.go
package main

import "fmt"

func main() {
	m := make(map[string]int)

	m["Answer"] = 42
	fmt.Println("The value:", m["Answer"])

	m["Answer"] = 48
	fmt.Println("The value:", m["Answer"])

	delete(m, "Answer")
	fmt.Println("The value:", m["Answer"])

	v, ok := m["Answer"]
	fmt.Println("The value:", v, "Present?", ok)
}
```
```:Run
The value: 42
The value: 48
The value: 0
The value: 0 Present? false
```

### 5.23. Exercise: Maps

ä»Šå›ã¯`WordCount`é–¢æ•°ã‚’å®Ÿè£…ã—ã¾ã™ã€‚
`string`ã§æ¸¡ã•ã‚Œã‚‹æ–‡ç« ã®å„å˜èªã®å‡ºç¾å›æ•°ã®mapã‚’è¿”ã—ã¾ã™ã€‚
`wc.Test`é–¢æ•°ã¯ãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆã‚’å®Ÿè¡Œã—æˆåŠŸã‹å¦ã‹ã‚’å‡ºåŠ›ã—ã¾ã™ã€‚

```go:exercise-maps.go
package main

import (
	"golang.org/x/tour/wc"
)

func WordCount(s string) map[string]int {
	return map[string]int{"x": 1}
}

func main() {
	wc.Test(WordCount)
}
```

#### 5.23.1. è§£ç­”ä¾‹

```diff go:exercise-maps.go
package main

import (
	"golang.org/x/tour/wc"
+	"strings"
)

func WordCount(s string) map[string]int {
+	m := make(map[string]int)
+	str := strings.Fields(s)
+	for _, v := range str {
+		m[v]++
+	}
+	return m
- return map[string]int{"x": 1}
}

func main() {
	wc.Test(WordCount)
}
```
```:Run
PASS
 f("I am learning Go!") = 
  map[string]int{"Go!":1, "I":1, "am":1, "learning":1}
PASS
 f("The quick brown fox jumped over the lazy dog.") = 
  map[string]int{"The":1, "brown":1, "dog.":1, "fox":1, "jumped":1, "lazy":1, "over":1, "quick":1, "the":1}
PASS
 f("I ate a donut. Then I ate another donut.") = 
  map[string]int{"I":2, "Then":1, "a":1, "another":1, "ate":2, "donut.":2}
PASS
 f("A man a plan a canal panama.") = 
  map[string]int{"A":1, "a":2, "canal":1, "man":1, "panama.":1, "plan":1}
```

### 5.24. Function values

é–¢æ•°ã‚‚å¤‰æ•°ã®ä¸€ç¨®ã§ã™ã®ã§ã€é–¢æ•°ã«é–¢æ•°ã‚’æ¸¡ã—ãŸã‚Šã€é–¢æ•°å€¤ã¯é–¢æ•°ã®å¼•æ•°ã«å–ã‚‹ã“ã¨ã‚‚ã€æˆ»ã‚Šå€¤ã¨ã—ã¦ã‚‚åˆ©ç”¨ã§ãã¾ã™ã€‚

ã¨ã¦ã‚‚ã‚„ã‚„ã“ã—ã„ã§ã™ã­ã€‚

```go:function-values.go
package main

import (
	"fmt"
	"math"
)

func compute(fn func(float64, float64) float64) float64 {
	return fn(3, 4)
}

func main() {
	hypot := func(x, y float64) float64 {
		return math.Sqrt(x*x + y*y)
	}
	fmt.Println(hypot(5, 12))

	fmt.Println(compute(hypot))
	fmt.Println(compute(math.Pow))
}
```
```:Run
13
5
81
```

### 5.25. Function closures

Golangã®é–¢æ•°ã¯`closure`(ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£)ã§ã€é–¢æ•°å†…ã§å®šç¾©ã•ã‚ŒãŸé–¢æ•°ã§ã‚ã‚Šã€å¤–éƒ¨å¤‰æ•°ã‚’å‚ç…§ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚ŠçŠ¶æ…‹ã‚’ä¿æŒã—ã€ã‚«ãƒ—ã‚»ãƒ«åŒ–å‡ºæ¥ã¾ã™ã€‚Javaã¨ã‹ã‚„ã£ãŸã“ã¨ã‚ã‚‹äººã¯ã‚ã‹ã‚Šã‚„ã™ã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚

```go:function-closures.go
package main

import "fmt"

func adder() func(int) int {
	sum := 0
	return func(x int) int {
		sum += x
		return sum
	}
}

func main() {
	pos, neg := adder(), adder()
	for i := 0; i < 10; i++ {
		fmt.Println(
			pos(i),
			neg(-2*i),
		)
	}
}
```
```:Run
0 0
1 -2
3 -6
6 -12
10 -20
15 -30
21 -42
28 -56
36 -72
45 -90
```

### 5.26. Exercise: Fibonacci closure

ãƒ•ã‚£ãƒœãƒŠãƒƒãƒé–¢æ•°ã‚’å®Ÿè£…ã—ã¾ã™ã€‚
ã“ã®é–¢æ•°ã¯é€£ç¶šã™ã‚‹ãƒ•ã‚£ãƒœãƒŠãƒƒãƒæ•°ã‚’è¿”ã™é–¢æ•°(ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£)ã‚’è¿”ã—ã¾ã™ã€‚

```go:exercise-fibonacci-closure.go
package main

import "fmt"

// fibonacci is a function that returns
// a function that returns an int.
func fibonacci() func() int {
}

func main() {
	f := fibonacci()
	for i := 0; i < 10; i++ {
		fmt.Println(f())
	}
}
```

#### 5.26.1. è§£ç­”ä¾‹
```diff go:exercise-fibonacci-closure.go
package main

import "fmt"

// fibonacci is a function that returns
// a function that returns an int.
+func fibonacci() func() int {
+	a, b := 0, 1
+	return func() int {
+		a, b = b, a+b
+		return a
+	}	
}

func main() {
	f := fibonacci()
	for i := 0; i < 10; i++ {
		fmt.Println(f())
	}
}
```
```:Run
21
â€‹
1
1
2
3
5
8
13
21
34
55
```

### 5.27. ã¾ã¨ã‚

- ãƒã‚¤ãƒ³ã‚¿ã®ã‚¼ãƒ­å€¤ã¯`nil`
- `&`ã§ã‚¢ãƒ‰ãƒ¬ã‚¹ã€`*`ã§å¤‰æ•°ã‚’è¡¨ã™
- ãƒã‚¤ãƒ³ã‚¿æ¼”ç®—ã¯ç„¡ã„
- `struct`ã¯`field`ã®é›†ã¾ã‚Š
- `field`ã¯`.`ã‚’ç”¨ã„ã¦ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹
- `:`ã§ç‰¹å®šã®å€¤ã ã‘åˆæœŸåŒ–ã™ã‚‹ã“ã¨ãŒã§ãã‚‹
- å…ˆé ­ã«`&`ã‚’ã¤ã‘ã‚‹ã¨æ–°ãŸãª`struct`ã¸ã®ãƒã‚¤ãƒ³ã‚¿ãŒä»£å…¥ã•ã‚Œã‚‹
- `[n]T`å‹ã¯ã€å‹`T`ã®`n`å€‹ã®å¤‰æ•°ã®`array`ã‚’è¡¨ã™
- é…åˆ—ã®é•·ã•ã‚’å¤‰ãˆã‚‹ã“ã¨ã¯ã§ããªã„
- å‹`[]T`ã¯å‹`T`ã®`slice`ã‚’è¡¨ã™
- ã‚¹ãƒ©ã‚¤ã‚¹ã¯å¯å¤‰é•·
- `slice`ã¯**é…åˆ—ã¸ã®ãƒã‚¤ãƒ³ã‚¿**ã«ã™ããªã„
- ã‚¹ãƒ©ã‚¤ã‚¹`s`ã®é•·ã•ã¯`len(s)`å®¹é‡ã¯`cap(s)`ã¨ã„ã†é–¢æ•°ã‚’åˆ©ç”¨ã™ã‚‹
- `make`é–¢æ•°ã§ã‚¹ãƒ©ã‚¤ã‚¹ã‚’è¿”ã—ã€é•·ã•ã¨å®¹é‡ã‚’æŒ‡å®šã§ãã‚‹
- ã‚¹ãƒ©ã‚¤ã‚¹ã®ä¸­ã«ã¯ã‚¹ãƒ©ã‚¤ã‚¹ã‚’å«ã‚ä»–ã®å‹ã‚’å…¥ã‚Œã‚‹ã“ã¨ãŒã§ãã‚‹
- ã‚¹ãƒ©ã‚¤ã‚¹ã«è¦ç´ ã‚’è¿½åŠ ã™ã‚‹ã¨ãã¯`append`é–¢æ•°ã‚’åˆ©ç”¨ã™ã‚‹
- `range`ã§é…åˆ—ã‚„ã‚¹ãƒ©ã‚¤ã‚¹ã‚’åå¾©å‡¦ç†å¯èƒ½
- ä¸€ã¤ã¯`index`ã€ã‚‚ã†ä¸€ã¤ã¯è¦ç´ ã®ã‚³ãƒ”ãƒ¼ã‚’è¿”ã™
- `_`ã«ä»£å…¥ã™ã‚‹ã“ã¨ã§å€¤ã‚’åˆ‡ã‚Šæ¨ã¦ã‚‹ã“ã¨ãŒå¯èƒ½
- `map`ã¯ã‚­ãƒ¼ã¨å€¤ã‚’é–¢é€£ä»˜ã‘ã‚‹
- `make`é–¢æ•°ã§æŒ‡å®šã•ã‚ŒãŸå‹ã®ãƒãƒƒãƒ—ã‚’åˆæœŸåŒ–ã—ã€ä½¿ç”¨å¯èƒ½ãªçŠ¶æ…‹ã§è¿”ã™
- mapãƒªãƒ†ãƒ©ãƒ«ã¯`key`ãŒå¿…è¦
- mapã«æ¸¡ã™å‹åãŒå˜ç´”ãªå‹åã®å ´åˆçœç•¥å¯èƒ½
- ã‚­ãƒ¼ã«å¯¾ã™ã‚‹è¦ç´ ãŒå­˜åœ¨ã™ã‚‹ã‹ã¯äºŒã¤ç›®ã®è¦ç´ (boolean)ã§åˆ¤æ–­
- é–¢æ•°ã‚‚å¤‰æ•°ã®ä¸€ç¨®
- Goã®é–¢æ•°ã¯`closure`ã§ã€ã‚«ãƒ—ã‚»ãƒ«åŒ–ãŒå¯èƒ½ã¨ãªã£ã¦ã„ã‚‹

:::

:::details Methods and interfaces

## 6. Methods and interfaces

### 6.1. Methods

Goè¨€èªã§ã¯ã€å‹ã«`method`(ãƒ¡ã‚½ãƒƒãƒ‰)ã‚’å®šç¾©ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
ä»¥ä¸‹ã®ä¾‹ã§ã¯ã€`Abs`ãƒ¡ã‚½ãƒƒãƒ‰ã¯`v`ã¨ã„ã†åã‚’æŒã¤`Vertex`å‹ã®ãƒ¬ã‚·ãƒ¼ãƒã‚’æŒã¤ã“ã¨ã‚’æ„å‘³ã—ã¦ã„ã¾ã™ã€‚

```go:methods.go
package main

import (
	"fmt"
	"math"
)

type Vertex struct {
	X, Y float64
}

func (v Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func main() {
	v := Vertex{3, 4}
	fmt.Println(v.Abs())
}
```
```:Run
5
```

### 6.2. Methods are functions

ä»Šå›ã®`Abs`ã¯å…ˆã»ã©ã¨åŒæ§˜ã®æ©Ÿèƒ½ã‚’ç¶­æŒã—ãŸã¾ã¾ã€é€šå¸¸ã®é–¢æ•°ã¨ã—ã¦è¨˜è¿°ã—ã¦ã„ã¾ã™ã€‚

```go:methods-funcs.go
package main

import (
	"fmt"
	"math"
)

type Vertex struct {
	X, Y float64
}

func Abs(v Vertex) float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func main() {
	v := Vertex{3, 4}
	fmt.Println(Abs(v))
}
```
```:Run
5
```

### 6.3. Methods continued

ä»»æ„ã®å‹ã«ã‚‚ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®£è¨€ã§ãã¾ã™ã€‚
ãƒ¬ã‚·ãƒ¼ãƒã‚’ä¼´ã†ãƒ¡ã‚½ãƒƒãƒ‰ã®å®£è¨€ã«ã¯ã€åŒä¸€ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸å†…ã«ãƒ¬ã‚·ãƒ¼ãƒå‹ãŒå­˜åœ¨ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

```go:methods-continued.go
package main

import (
	"fmt"
	"math"
)

type MyFloat float64

func (f MyFloat) Abs() float64 {
	if f < 0 {
		return float64(-f)
	}
	return float64(f)
}

func main() {
	f := MyFloat(-math.Sqrt2)
	fmt.Println(f.Abs())
}
```
```:Run
1.4142135623730951
```

### 6.4. Pointer receivers

ãƒã‚¤ãƒ³ã‚¿ãƒ¬ã‚·ãƒ¼ãƒã§ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®£è¨€ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚
ãƒ¬ã‚·ãƒ¼ãƒè‡ªèº«ã‚’å¤‰æ›´ã—ãŸã„éš›ã¯ãƒã‚¤ãƒ³ã‚¿ãƒ¬ã‚·ãƒ¼ãƒã«ã—ã¾ã™ã€‚
ã“ã‚Œã¯ã„ã‚ã‚†ã‚‹ç ´å£Šçš„å‡¦ç†ã¨è¨€ã‚ã‚Œã‚‹ã‚ˆã†ãªã‚‚ã®ã ã¨æ€ã„ã¾ã™ã€‚
é€†ã«éç ´å£Šçš„å‡¦ç†ã‚’æ±‚ã‚ã‚‹å ´åˆã¯å‰å›ã®ã‚ˆã†ãªå¤‰æ•°ãƒ¬ã‚·ãƒ¼ãƒã«ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
ä»Šå›ã®å ´åˆã€`Scale`é–¢æ•°ã‚’å¤‰æ•°ãƒ¬ã‚·ãƒ¼ãƒ(`v Vertex`)ã¨ã™ã‚‹ã¨`Run`ã¯`5`ã¨ãªã‚Šã¾ã™ã€‚

```go:methods-pointers.go
package main

import (
	"fmt"
	"math"
)

type Vertex struct {
	X, Y float64
}

func (v Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func (v *Vertex) Scale(f float64) {
	v.X = v.X * f
	v.Y = v.Y * f
}

func main() {
	v := Vertex{3, 4}
	v.Scale(10)
	fmt.Println(v.Abs())
}
```
```:Run
50
```

### 6.5. Pointers and functions

ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã¯å…ˆã»ã©ã®`Abs`ã¨`Scale`ãƒ¡ã‚½ãƒƒãƒ‰ã‚’é–¢æ•°ã«æ›¸ãç›´ã—ã¦ã‚ã‚Šã¾ã™ã€‚

```go:methods-pointers-explained.go
package main

import (
	"fmt"
	"math"
)

type Vertex struct {
	X, Y float64
}

func Abs(v Vertex) float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func Scale(v *Vertex, f float64) {
	v.X = v.X * f
	v.Y = v.Y * f
}

func main() {
	v := Vertex{3, 4}
	Scale(&v, 10)
	fmt.Println(Abs(v))
}
```
```:Run
50
```

### 6.6. Methods and pointer indirection

ãƒ¡ã‚½ãƒƒãƒ‰ãŒãƒã‚¤ãƒ³ã‚¿ãƒ¬ã‚·ãƒ¼ãƒã®å ´åˆã€å‘¼ã³å‡ºã—æ™‚ã«å¤‰æ•°ã€ãƒã‚¤ãƒ³ã‚¿ã©ã¡ã‚‰ã§ã‚‚ãƒ¬ã‚·ãƒ¼ãƒã¨ã—ã¦å–ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
`v.scale(5)`ã¯Goã®å ´åˆåˆ©ä¾¿æ€§ã®ãŸã‚`(&v).scale(5)`ã¨ã—ã¦å‡¦ç†ã•ã‚Œã¾ã™ã€‚

é–¢æ•°ã®å ´åˆã¯ç‰¹å®šã®å‹ã‚’å–ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

```go:indirection.go
package main

import "fmt"

type Vertex struct {
	X, Y float64
}

func (v *Vertex) Scale(f float64) {
	v.X = v.X * f
	v.Y = v.Y * f
}

func ScaleFunc(v *Vertex, f float64) {
	v.X = v.X * f
	v.Y = v.Y * f
}

func main() {
	v := Vertex{3, 4}
	v.Scale(2)
	ScaleFunc(&v, 10)

	p := &Vertex{4, 3}
	p.Scale(3)
	ScaleFunc(p, 8)

	fmt.Println(v, p)
}
```
```:Run
{60 80} &{96 72}
```

### 6.7. Methods and pointer indirection (2)

ãƒ¡ã‚½ãƒƒãƒ‰ãŒå¤‰æ•°ãƒ¬ã‚·ãƒ¼ãƒã®å ´åˆã‚‚ã€å¤‰æ•°ã€ãƒã‚¤ãƒ³ã‚¿ã©ã¡ã‚‰ã§ã‚‚ãƒ¬ã‚·ãƒ¼ãƒã¨ã—ã¦å–ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

```go:indirection-values.go
package main

import (
	"fmt"
	"math"
)

type Vertex struct {
	X, Y float64
}

func (v Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func AbsFunc(v Vertex) float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func main() {
	v := Vertex{3, 4}
	fmt.Println(v.Abs())
	fmt.Println(AbsFunc(v))

	p := &Vertex{4, 3}
	fmt.Println(p.Abs())
	fmt.Println(AbsFunc(*p))
}
```
```:Run
5
5
5
5
```

### 6.8. Choosing a value or pointer receiver

ãƒã‚¤ãƒ³ã‚¿ãƒ¬ã‚·ãƒ¼ãƒã‚’ç”¨ã„ã‚‹åˆ©ç‚¹ã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™ã€‚
1. ç ´å£Šçš„å‡¦ç†ã‚’å®Ÿè¡Œã™ã‚‹
2. ãƒ¡ã‚½ãƒƒãƒ‰ã®å‘¼ã³å‡ºã—æ¯ã«å¤‰æ•°ã®ã‚³ãƒ”ãƒ¼ã‚’è¡Œã‚ãªã„
(2.)ã«é–¢ã—ã¦ã¯ã€å¤§ããªæ§‹é€ ä½“ã®éš›ã«æœ‰åŠ¹ã§ã™ã€‚
ä¸€èˆ¬çš„ã«ã€ãƒ¬ã‚·ãƒ¼ãƒã¯å€¤ã¨ãƒã‚¤ãƒ³ã‚¿ã‚’æ··åœ¨ã•ã›ã‚‹ã¹ãã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚

```go:methods-with-pointer-receivers.go
package main

import (
	"fmt"
	"math"
)

type Vertex struct {
	X, Y float64
}

func (v *Vertex) Scale(f float64) {
	v.X = v.X * f
	v.Y = v.Y * f
}

func (v *Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func main() {
	v := &Vertex{3, 4}
	fmt.Printf("Before scaling: %+v, Abs: %v\n", v, v.Abs())
	v.Scale(5)
	fmt.Printf("After scaling: %+v, Abs: %v\n", v, v.Abs())
}
```
```:Run
Before scaling: &{X:3 Y:4}, Abs: 5
After scaling: &{X:15 Y:20}, Abs: 25
```

### 6.9. Interfaces

`interface`(ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹)ã¯ã€ãƒ¡ã‚½ãƒƒãƒ‰ã®ã‚·ã‚°ãƒ‹ãƒãƒ£ã®é›†ã¾ã‚Šã§è¡¨ã•ã‚Œã¾ã™ã€‚
ãã®ãƒ¡ã‚½ãƒƒãƒ‰ã®é›†ã¾ã‚Šã‚’å®Ÿè£…ã—ãŸå€¤ã‚’ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹å‹ã®å¤‰æ•°ã¸æŒãŸã›ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

ã¤ã¾ã‚Šä»¥ä¸‹ã®ä¾‹ã§ã‚¨ãƒ©ãƒ¼ãŒå‡ºã‚‹ã®ã¯ã€`Abs`ãƒ¡ã‚½ãƒƒãƒ‰ãŒ`*Vertex`ã®å®šç¾©ã§ã‚ã‚‹ãŸã‚ã€`Vertex`ã§ã‚ã‚‹`v`ã¯`a`ã¸ä»£å…¥ã™ã‚‹ã“ã¨ã¯ã§ããªã„ãŸã‚ã§ã™ã€‚

```go:interfaces.go
package main

import (
	"fmt"
	"math"
)

type Abser interface {
	Abs() float64
}

func main() {
	var a Abser
	f := MyFloat(-math.Sqrt2)
	v := Vertex{3, 4}

	a = f  // a MyFloat implements Abser
	a = &v // a *Vertex implements Abser

	// In the following line, v is a Vertex (not *Vertex)
	// and does NOT implement Abser.
	a = v

	fmt.Println(a.Abs())
}

type MyFloat float64

func (f MyFloat) Abs() float64 {
	if f < 0 {
		return float64(-f)
	}
	return float64(f)
}

type Vertex struct {
	X, Y float64
}

func (v *Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}
```
```:Run
./prog.go:22:6: cannot use v (variable of type Vertex) as Abser value in assignment: Vertex does not implement Abser (method Abs has pointer receiver)
```

### 6.10. Interfaces are implemented implicitly

å‹ã«ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è¿½åŠ ã—ã¦ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’å®Ÿè£…ã—ã¾ã™ã€‚
ã¾ãŸGoè¨€èªã«ã¯ã€`æš—é»™ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹`ã¨ã„ã†ã‚‚ã®ãŒã‚ã‚Šã€ã“ã‚Œã¯ç•°ãªã‚‹ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®ã€å‹ãŒåŒã˜ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’å®Ÿè£…ã™ã‚‹ã“ã¨ãŒå‡ºæ¥ã‚‹ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™ã€‚

```go:interfaces-are-satisfied-implemented.go
package main

import "fmt"

type I interface {
	M()
}

type T struct {
	S string
}

// This method means type T implements the interface I,
// but we don't need to explicitly declare that it does so.
func (t T) M() {
	fmt.Println(t.S)
}

func main() {
	var i I = T{"hello"}
	i.M()
}
```
```:Run
hello
```

### 6.11. Interface values

ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã¯ã€å€¤ã¨å‹ã®ã‚¿ãƒ—ãƒ«ã®ã‚ˆã†ã«ã—ã¦è€ƒãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
`(value, type)`
å€¤ã¯ã€ç‰¹å®šã®åŸºåº•ã¨ãªã‚‹å…·ä½“çš„ãªå‹ã®å€¤ã‚’ä¿æŒã—ã€ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™ã¨ãã®å‹ã¨åŒã˜ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚

ãªã‚“ã ã‹ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰ã£ã½ã„å°è±¡ã‚’å—ã‘ã¾ã—ãŸã€‚

```go:interface-values.go
package main

import (
	"fmt"
	"math"
)

type I interface {
	M()
}

type T struct {
	S string
}

func (t *T) M() {
	fmt.Println(t.S)
}

type F float64

func (f F) M() {
	fmt.Println(f)
}

func main() {
	var i I

	i = &T{"Hello"}
	describe(i)
	i.M()

	i = F(math.Pi)
	describe(i)
	i.M()
}

func describe(i I) {
	fmt.Printf("(%v, %T)\n", i, i)
}
```
```:Run
(&{Hello}, *main.T)
Hello
(3.141592653589793, main.F)
3.141592653589793
```

### 6.12. Interface values with nil underlying values

å€¤ãŒ`nil`ã®æ™‚ã€Goè¨€èªã§ã¯ãƒŒãƒ«ãƒã«ã¯ãªã‚‰ãš`nil`ã‚’ãƒ¬ã‚·ãƒ¼ãƒã¨ã—ã¦å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚`nil`ã§å‘¼ã³å‡ºã•ã‚Œã¦ã‚‚é©åˆ‡ã«å‡¦ç†ã™ã‚‹ã‚ˆã†è¨˜è¿°ã—ã¦ãŠãã®ãŒä¸€èˆ¬çš„ã¨ã•ã‚Œã¦ã„ã¾ã™ã€‚

```go:interface-values-with-nil.go
package main

import "fmt"

type I interface {
	M()
}

type T struct {
	S string
}

func (t *T) M() {
	if t == nil {
		fmt.Println("<nil>")
		return
	}
	fmt.Println(t.S)
}

func main() {
	var i I

	var t *T
	i = t
	describe(i)
	i.M()

	i = &T{"hello"}
	describe(i)
	i.M()
}

func describe(i I) {
	fmt.Printf("(%v, %T)\n", i, i)
}
```
```:Run
(<nil>, *main.T)
<nil>
(&{hello}, *main.T)
hello
```
### 6.13. Nil interface values

`nil`ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã«ã¯å…·ä½“çš„ãªå€¤ã‚‚å‹ã‚‚å­˜åœ¨ã—ã¾ã›ã‚“ã€‚ã‚ˆã£ã¦ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™ã¨ã‚¨ãƒ©ãƒ¼ã¨ãªã‚Šã¾ã™ã€‚

```go:nil-interface-values.go
package main

import "fmt"

type I interface {
	M()
}

func main() {
	var i I
	describe(i)
	i.M()
}

func describe(i I) {
	fmt.Printf("(%v, %T)\n", i, i)
}
```
```:Run
(<nil>, <nil>)
panic: runtime error: invalid memory address or nil pointer dereference
[signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x482501]

goroutine 1 [running]:
main.main()
	/tmp/sandbox1367158980/prog.go:12 +0x61
```

### 6.14. The empty interface

0å€‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒæŒ‡å®šã•ã‚ŒãŸã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã¯ã€`ç©ºã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹`ã¨å‘¼ã°ã‚Œã€ä»»æ„ã®å€¤ã®å‹ã‚’ä¿æŒã§ãã¾ã™ã€‚
æœªçŸ¥ã®å‹ã‚’æ‰±ã†éš›ã«åˆ©ç”¨ã•ã‚Œã€ä¾‹ãˆã°`fmt.Print`ã§ã¯`interface{}`å‹ã®ä»»æ„ã®å¼•æ•°ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚

```go:empty-interface.go
package main

import "fmt"

func main() {
	var i interface{}
	describe(i)

	i = 42
	describe(i)

	i = "hello"
	describe(i)
}

func describe(i interface{}) {
	fmt.Printf("(%v, %T)\n", i, i)
}
```
```:Run
(<nil>, <nil>)
(42, int)
(hello, string)
```

### 6.15. Type assertions

`type assertion`(å‹ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³)ã¯å€¤ã®åŸºã«ãªã‚‹å…·ä½“çš„ãªå€¤ã‚’åˆ©ç”¨ã™ã‚‹æ‰‹æ®µã‚’æä¾›ã—ã¾ã™ã€‚
`t := i.(T)`
`i`ãŒå‹`T`ã‚’ä¿æŒã—`t`ã«ä»£å…¥ã•ã‚Œã¾ã™ã€‚ã“ã®æ™‚`i`ãŒ`T`ã‚’ä¿æœ‰ã—ã¦ã„ãªã‘ã‚Œã°`panic`ã‚’å¼•ãèµ·ã“ã—ã¾ã™ã€‚
`t, ok := i.(T)`
ã—ã‹ã—ä¸Šè¨˜ã®ã‚ˆã†ã«ã™ã‚‹ã¨ã€`ok`ã«`i`ãŒ`T`ã‚’ä¿æœ‰ã—ã¦ã„ã‚‹ã‹ã®`boolean`ãŒè¿”ã•ã‚Œã€ä¿æœ‰ã—ã¦ã„ã‚Œã°`true`ã‚’ã€ãã†ã§ãªã‘ã‚Œã°`false`ã‚’è¿”ã—ã¾ã™ã€‚ã¾ãŸã€`t`ã«ã¯ãã®å€¤ã€ã‚‚ã—ãã¯ã‚¼ãƒ­å€¤ãŒä»£å…¥ã•ã‚Œã¾ã™ã€‚

```go:type-assertions.go
package main

import "fmt"

func main() {
	var i interface{} = "hello"

	s := i.(string)
	fmt.Println(s)

	s, ok := i.(string)
	fmt.Println(s, ok)

	f, ok := i.(float64)
	fmt.Println(f, ok)

	f = i.(float64) // panic
	fmt.Println(f)
}
```
```:Run
hello
hello true
0 false
panic: interface conversion: interface {} is string, not float64

goroutine 1 [running]:
main.main()
	/tmp/sandbox3937253924/prog.go:17 +0x14a
```

### 6.16. Type switches

`type switch`ã¯é€šå¸¸ã®`switch`æ–‡ã®ã‚ˆã†ã«ã—ã¦ä½¿ãˆã¾ã™ãŒã€æ¯”è¼ƒå¯¾è±¡ãŒå€¤ã§ã¯ãªãå‹ã¨ãªã‚Šã€`type assersion`ã®`()`å†…ã¯`type`ã¨æ›¸ãã¾ã™ã€‚

```go:type-switches.go
package main

import "fmt"

func do(i interface{}) {
	switch v := i.(type) {
	case int:
		fmt.Printf("Twice %v is %v\n", v, v*2)
	case string:
		fmt.Printf("%q is %v bytes long\n", v, len(v))
	default:
		fmt.Printf("I don't know about type %T!\n", v)
	}
}

func main() {
	do(21)
	do("hello")
	do(true)
}
```
```:Run
Twice 21 is 42
"hello" is 5 bytes long
I don't know about type bool!
```

### 6.17. Stringers

æœ€ã‚‚ã‚ˆãä½¿ã‚ã‚Œã¦ã„ã‚‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã®ä¸€ã¤ã«ã€`stringer`ã¨ã„ã†ã‚‚ã®ãŒã‚ã‚Šã¾ã™ã€‚
ã“ã‚Œã¯`fmt`ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸å«ã¾ã‚Œã¦ãŠã‚Šã€å¤‰æ•°ã‚’æ–‡å­—åˆ—ã¨ã—ã¦å‡ºåŠ›ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚

```go:stringer.go
package main

import "fmt"

type Person struct {
	Name string
	Age  int
}

func (p Person) String() string {
	return fmt.Sprintf("%v (%v years)", p.Name, p.Age)
}

func main() {
	a := Person{"Arthur Dent", 42}
	z := Person{"Zaphod Beeblebrox", 9001}
	fmt.Println(a, z)
}
```
```:Run
Arthur Dent (42 years) Zaphod Beeblebrox (9001 years)
```

### 6.18. Exercise: Stringers

`IPAddr`å‹ã‚’å®Ÿè£…ã—ã¾ã™ã€‚
IPã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’ãƒ‰ãƒƒãƒˆã§å››ã¤ã«åŒºåˆ‡ã£ãŸè¡¨ç¾ã§å‡ºåŠ›ã™ã‚‹ãŸã‚ã«ã€`fmt.Stringer`ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’å®Ÿè£…ã—ã¾ã™ã€‚

(ä¾‹ : IPAddr{1, 2, 3, 4}ã¯"1.2.3.4")

```go:exercise-stringer.go
package main

import "fmt"

type IPAddr [4]byte

// TODO: Add a "String() string" method to IPAddr.

func main() {
	hosts := map[string]IPAddr{
		"loopback":  {127, 0, 0, 1},
		"googleDNS": {8, 8, 8, 8},
	}
	for name, ip := range hosts {
		fmt.Printf("%v: %v\n", name, ip)
	}
}
```
#### 6.18.1. è§£ç­”ä¾‹
å‰å›ã®ã‚ˆã†ã«ã—ã¦`Print`ã™ã‚‹éš›ã®å‡ºåŠ›å½¢å¼ã‚’å¤‰æ›´ã—ã¦ã‚ã’ã¾ã™ã€‚
ã¾ãŸã€ãƒ€ãƒ–ãƒ«ã‚³ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³(`""`)ã¯ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã§ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã—ã¾ã™ã€‚
``` diff go:exercise-stringer.go
package main

import "fmt"

type IPAddr [4]byte

// TODO: Add a "String() string" method to IPAddr.

+func (ip IPAddr) String() string {
+	return fmt.Sprintf("\"%d.%d.%d.%d\"", ip[0], ip[1], ip[2], ip[3])
+}

func main() {
	hosts := map[string]IPAddr{
		"loopback":  {127, 0, 0, 1},
		"googleDNS": {8, 8, 8, 8},
	}
	for name, ip := range hosts {
		fmt.Printf("%v: %v\n", name, ip)
	}
}
```
```:Run
loopback: "127.0.0.1"
googleDNS: "8.8.8.8"
```

### 6.19. Errors

Goè¨€èªã¯ã‚¨ãƒ©ãƒ¼ã®çŠ¶æ…‹ã‚’`error`ã§è¡¨ã—ã¾ã™ã€‚
`error`å‹ã¯ä»¥ä¸‹ã®ã‚ˆã†ãªçµ„ã¿è¾¼ã¿å‹ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã§ã™ã€‚
`type error interface {
    Error() string
}`
`error`ã®å–ã‚Šæ‰±ã„ã¯å€¤ãŒ`nil`ã‹å¦ã‹ã§åˆ¤æ–­ã—ã¾ã™ã€‚

```go:errors.go
package main

import (
	"fmt"
	"time"
)

type MyError struct {
	When time.Time
	What string
}

func (e *MyError) Error() string {
	return fmt.Sprintf("at %v, %s",
		e.When, e.What)
}

func run() error {
	return &MyError{
		time.Now(),
		"it didn't work",
	}
}

func main() {
	if err := run(); err != nil {
		fmt.Println(err)
	}
}
```
```:Run
at 2009-11-10 23:00:00 +0000 UTC m=+0.000000001, it didn't work
```

### 6.20. Exercise: Errors

`Sqrt`é–¢æ•°ã§è² ã®æ•°ãŒä¸ãˆã‚‰ã‚ŒãŸéš›ã«`error`ã‚’è¿”ã™ã‚ˆã†ã«ã—ã¾ã™ã€‚
ä»¥ä¸‹ã®æ–°ã—ã„å‹ã‚’ä½œæˆã—ã¾ã™ã€‚
`type ErrNegativeSqrt float64`
ã¾ãŸã€`ErrNegativeSqrt(-2).Error()`ã§ã€`"cannot Sqrt negative number: -2"`ã‚’è¿”ã™
`func (e ErrNegativeSqrt) Error() string`
ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ã€`error`ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚’æº€ãŸã™ã‚ˆã†ã«ã—ã¾ã™ã€‚

```go:exercise-errors.go
package main

import (
	"fmt"
)

func Sqrt(x float64) (float64, error) {
	return 0, nil
}

func main() {
	fmt.Println(Sqrt(2))
	fmt.Println(Sqrt(-2))
}
```

#### 6.20.1. è§£ç­”ä¾‹

`Error`ãƒ¡ã‚½ãƒƒãƒ‰å†…ã§`fmt.Sprint(e)`ã¨ã™ã‚‹ã¨ç„¡é™ãƒ«ãƒ¼ãƒ—ã¨ãªã‚Šã¾ã™ã€‚ç†ç”±ã¯ã€`Error`ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹ãŸã³ã«`Error`ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹(å†å¸°çš„)ãŸã‚ã§ã™ã€‚
ã“ã“ã§`fmt.Sprint(float(e))`ã¨ã™ã‚‹äº‹ã§`e`ã‚’æ–‡å­—åˆ—ã«å¤‰æ›ã—ã€ãƒ«ãƒ¼ãƒ—ã«é™¥ã‚‹ã“ã¨ã‚’é˜²ãã“ã¨ãŒã§ãã¾ã™ã€‚

```diff go:exersise-errors.go
package main

import (
	"fmt"
)

+type ErrNegativeSqrt float64

+func (e ErrNegativeSqrt) Error() string {
+	return fmt.Sprintf("cannot Sqrt negative number: %v", float64(e))
+}

+func Sqrt(x float64) (float64, error) {
+	if x < 0 {
+		return 0, ErrNegativeSqrt(x)
+	}
+	z := 1.0
+	for i := 0; i < 10; i++ {
+		z -= (z*z - x) / (2*z)
+	}
+	return z, nil
+}

func main() {
	fmt.Println(Sqrt(2))
	fmt.Println(Sqrt(-2))
}														
```
```:Run
1.414213562373095 <nil>
0 cannot Sqrt negative number: -2
```

### 6.21. Readers

`io`ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¯ãƒ‡ãƒ¼ã‚¿ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’èª­ã‚€`io.Reader`ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’è¦å®šã—ã¦ã„ã¾ã™ã€‚
`io.Reader`ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã¯`Read`ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã¡ã¾ã™ã€‚ä¸ãˆã‚‰ã‚ŒãŸãƒã‚¤ãƒˆã‚¹ãƒ©ã‚¤ã‚¹ã¸å…¥ã‚Œã€ãƒã‚¤ãƒˆã®ã‚µã‚¤ã‚ºã¨ã‚¨ãƒ©ãƒ¼ã®å€¤ã‚’è¿”ã—ã¾ã™ã€‚
çµ‚ç«¯ã¯`io.EOF`ã®ã‚¨ãƒ©ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚

ä»Šå›ã¯8byteæ¯ã«å‘¼ã³å‡ºã—ã¦ã„ã¾ã™ã€‚

```go:reader.go
package main

import (
	"fmt"
	"io"
	"strings"
)

func main() {
	r := strings.NewReader("Hello, Reader!")

	b := make([]byte, 8)
	for {
		n, err := r.Read(b)
		fmt.Printf("n = %v err = %v b = %v\n", n, err, b)
		fmt.Printf("b[:n] = %q\n", b[:n])
		if err == io.EOF {
			break
		}
	}
}
```
```:Run
n = 8 err = <nil> b = [72 101 108 108 111 44 32 82]
b[:n] = "Hello, R"
n = 6 err = <nil> b = [101 97 100 101 114 33 32 82]
b[:n] = "eader!"
n = 0 err = EOF b = [101 97 100 101 114 33 32 82]
b[:n] = ""
```

### 6.22. Exercise: Readers

ã‚¢ã‚¹ã‚­ãƒ¼æ–‡å­—`A`ã®ç„¡é™ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’å‡ºåŠ›ã™ã‚‹`Reader`å‹ã‚’å®šç¾©ã—ã¾ã™ã€‚

```go:exercise-reader.go
package main

import "golang.org/x/tour/reader"

type MyReader struct{}

// TODO: Add a Read([]byte) (int, error) method to MyReader.

func main() {
	reader.Validate(MyReader{})
}
```

#### 6.22.1. è§£ç­”ä¾‹

`range b`ã¯ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¿”ã™ã®ã§`for`æ–‡ã§å›ã™äº‹ã§`A`ã‚’ä»£å…¥ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

```diff go:exercise-reader.go
package main

import "golang.org/x/tour/reader"

type MyReader struct{}

// TODO: Add a Read([]byte) (int, error) method to MyReader.

+func (r MyReader) Read(b []byte) (int, error) +{
+	for i := range b {
+		b[i] = 'A'
+	}
+	return len(b), nil
+}

func main() {
	reader.Validate(MyReader{})
}
```
```:Run
OK!
```

### 6.23. Exercise: rot13Reader

```go:exercise-rot-reader.go
package main

import (
	"io"
	"os"
	"strings"
)

type rot13Reader struct {
	r io.Reader
}

func main() {
	s := strings.NewReader("Lbh penpxrq gur pbqr!")
	r := rot13Reader{s}
	io.Copy(os.Stdout, &r)
}
```

#### 6.23.1. è§£ç­”ä¾‹

ã¾ãšã‚¨ãƒ©ãƒ¼ã®å‡¦ç†ã‚’è¡Œã„ã€ãã®å¾Œrot13ã®æš—å·åŒ–ã‚’è¡Œã„ã¾ã™ã€‚

```diff go:exercise-rot-reader.go
package main

import (
	"io"
	"os"
	"strings"
)

type rot13Reader struct {
	r io.Reader
}

+func (rr *rot13Reader) Read(b []byte) (int, error) {
+	n, err := rr.r.Read(b)
+	if err != nil {
+		return n, err
+	}

+	for i := 0; i < n; i++ {
+		if (b[i] >= 'A' && b[i] < 'N') || (b[i] >= 'a' && b[i] < 'n') {
+			b[i] += 13
+		} else if (b[i] > 'M' && b[i] <= 'Z') || (b[i] > 'm' && b[i] <= 'z') {
+			b[i] -= 13
+		}
+	}

+	return n, nil
+}

func main() {
	s := strings.NewReader("Lbh penpxrq gur pbqr!")
	r := rot13Reader{s}
	io.Copy(os.Stdout, &r)
}
```
```:Run
You cracked the code!
```

### 6.24. Images

`image`ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¯ã€æ¬¡ã®ã‚ˆã†ãª`Image`ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’å®Ÿè£…ã—ã¦ã„ã¾ã™ã€‚
`type Image interface {
    ColorModel() color.Model
    Bounds() Rectangle
    At(x, y int) color.Color
}`
`Rectangle`ã¯ã€`image`ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã® 
`image.Rectangle`ã«å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚

`color.Color`,`color.Model`ã¯ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã§ã™ãŒã€å®šç¾©æ¸ˆã¿ã®`color.RGBA`,`color.RGBAModel`ã‚’ä½¿ç”¨ã—ã€ç„¡è¦–ã§ãã¾ã™ã€‚ ã“ã‚Œã‚‰ã¯ã€`image/color`ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã«å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚

```go:images.go
package main

import (
	"fmt"
	"image"
)

func main() {
	m := image.NewRGBA(image.Rect(0, 0, 100, 100))
	fmt.Println(m.Bounds())
	fmt.Println(m.At(0, 0).RGBA())
}
```
```:Run
(0,0)-(100,100)
0 0 0 0
```

### 6.25. Exercise: Images

`image.Image`ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã®å®Ÿè£…ã‚’è¿”ã—ã¾ã™ã€‚
`Image`å‹ã‚’å®šç¾©ã—ã¦å¿…è¦ãªãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ã€`pic.ShowImage`ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚

`Bounds`ã¯ã€`image.Rect(0, 0, w, h)`ã®ã‚ˆã†ã«ã—ã¦`image.Rectangle`ã‚’è¿”ã—ã¾ã™ã€‚

`ColorModel`ã¯ã€`color.RGBAModel`ã‚’è¿”ã—ã¾ã™ã€‚

`At`ã¯ã²ã¨ã¤ã®è‰²ã‚’è¿”ã—ã¾ã™ã€‚
ç”Ÿæˆã™ã‚‹ç”»åƒã®è‰²ã®å€¤`v`ã‚’`color.RGBA{v, v, 255, 255}`ã‚’åˆ©ç”¨ã—ã¦è¿”ã—ã¾ã™ã€‚

```go:exercise-images.go
package main

import "golang.org/x/tour/pic"

type Image struct{}

func main() {
	m := Image{}
	pic.ShowImage(m)
}
```

#### 6.25.1. è§£ç­”ä¾‹

`Image`ã¯ç¸¦æ¨ª256ãƒ”ã‚¯ã‚»ãƒ«ã®ç”»åƒã‚’è¡¨ç¾ã™ã‚‹æ§‹é€ ä½“ã§ã€`Bounds`ãƒ¡ã‚½ãƒƒãƒ‰ã§ç”»åƒã®ç¯„å›²ã‚’å®šç¾©ã—ã€`ColorModel`ãƒ¡ã‚½ãƒƒãƒ‰ã§ã‚«ãƒ©ãƒ¼ãƒ¢ãƒ‡ãƒ«ã‚’å®šç¾©ã—ã€`At`ãƒ¡ã‚½ãƒƒãƒ‰ã§å„ãƒ”ã‚¯ã‚»ãƒ«ã®è‰²ã‚’å®šç¾©ã—ã¦ã„ã¾ã™ã€‚
`pic.ShowImage`é–¢æ•°ã‚’å‘¼ã³å‡ºã™ã“ã¨ã§ã€ã“ã®`Image`ã®å®Ÿè£…ã«åŸºã¥ã„ãŸç”»åƒãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚

```go:exercise-images-ans.go
package main

import (
	"image"
	"image/color"

	"golang.org/x/tour/pic"
)

type Image struct {
	w, h int
}

func (i Image) Bounds() image.Rectangle {
	return image.Rect(0, 0, i.w, i.h)
}

func (i Image) ColorModel() color.Model {
	return color.RGBAModel
}

func (i Image) At(x, y int) color.Color {
	v := uint8((x + y) / 2)
	return color.RGBA{v, v, 255, 255}
}

func main() {
	m := Image{256, 256}
	pic.ShowImage(m)
}
```
**Run**
![](/images/398bb7daebb893/2023-03-21-05-22-25.png)

### 6.26. ã¾ã¨ã‚
- structã‚’å«ã‚€ä»»æ„ã®å‹ã«`method`ã‚’å®šç¾©å¯èƒ½
- ãƒã‚¤ãƒ³ã‚¿ãƒ¬ã‚·ãƒ¼ãƒã§å®£è¨€å¯èƒ½(ç ´å£Šçš„å‡¦ç†)
- ãƒ¡ã‚½ãƒƒãƒ‰ã¯å‘¼ã³å‡ºã—æ™‚ã«å¤‰æ•°ã€ãƒã‚¤ãƒ³ã‚¿ã©ã¡ã‚‰ã§ã‚‚ãƒ¬ã‚·ãƒ¼ãƒã¨ã—ã¦å–ã‚‹ã“ã¨ãŒå¯èƒ½ã€‚
- é–¢æ•°ã¯ç‰¹å®šã®å‹ã‚’å–ã‚‹å¿…è¦ãŒã‚ã‚‹
- ãƒ¬ã‚·ãƒ¼ãƒã¯å€¤ã‹ãƒã‚¤ãƒ³ã‚¿ã§æ··åœ¨ã•ã›ã‚‹ã¹ãã§ã¯ãªã„
- `interface`(ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹)ã¯ã€ãƒ¡ã‚½ãƒƒãƒ‰ã®ã‚·ã‚°ãƒ‹ãƒãƒ£ã®é›†ã¾ã‚Šã€‚
- ãã®ãƒ¡ã‚½ãƒƒãƒ‰ã®é›†ã¾ã‚Šã‚’å®Ÿè£…ã—ãŸå€¤ã‚’`interface`å‹ã®å¤‰æ•°ã«æŒãŸã›ã‚‹ã“ã¨ãŒå¯èƒ½
- å‹ã«ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è¿½åŠ ã—ã¦ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’å®Ÿè£…ã™ã‚‹
- `æš—é»™ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹`ã«ã‚ˆã‚Šç•°ãªã‚‹ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®ã€å‹ãŒåŒã˜ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’å®Ÿè£…å¯èƒ½
- ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã¯å€¤ã¨å‹ã®ã‚¿ãƒ—ãƒ«ã¨ã—ã¦è€ƒãˆã‚‰ã‚Œã‚‹
- å€¤ã®å‹ã¨åŒã˜ãƒ¡ã‚½ãƒƒãƒ‰ãŒå®Ÿè¡Œã•ã‚Œã‚‹
- å€¤ãŒ`nil`ã§ã‚‚å®Ÿè¡Œã•ã‚Œã‚‹ãŸã‚é©åˆ‡ãªå‡¦ç†ã‚’è¨˜è¿°ã—ã¦ãŠã
- `nil`ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã«ã¯å…·ä½“çš„ãªå€¤ã‚‚å‹ã‚‚å­˜åœ¨ã—ãªã„ãŸã‚ã€ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™ã¨ã‚¨ãƒ©ãƒ¼ã¨ãªã‚‹
- `ç©ºã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹`ã¯ä»»æ„ã®å€¤ã®å‹ã‚’ä¿æŒã™ã‚‹ã€‚
- `type assersion`ã¯ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã®å€¤ã®åŸºã«ãªã‚‹å…·ä½“çš„ãªå€¤ã‚’åˆ©ç”¨ã™ã‚‹æ‰‹æ®µã‚’æä¾›ã™ã‚‹
- `type switch`ã¯å€¤ã®å‹ã‚’æ¯”è¼ƒã™ã‚‹
- `stringer`ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã¯å¤‰æ•°ã‚’æ–‡å­—åˆ—ã¨ã—ã¦å‡ºåŠ›ã™ã‚‹ãŸã‚ã«åºƒãåˆ©ç”¨ã•ã‚Œã¦ã„ã‚‹
- `error`å‹ã‚‚çµ„ã¿è¾¼ã¿å‹ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹
- `nil`ã‹å¦ã‹ã§åˆ¤æ–­ã™ã‚‹
- `io`ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¯ãƒ‡ãƒ¼ã‚¿ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’èª­ã‚€`io.Reader`ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’è¦å®šã—ã¦ã„ã‚‹
- `Read`ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã¡ã€çµ‚ç«¯ã¯`io.EOF`ã®ã‚¨ãƒ©ãƒ¼ã‚’è¿”ã™
- `Image`ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã¯`ColorModel`,`Bounds`,`At`ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã¤

:::
:::details 6
:::